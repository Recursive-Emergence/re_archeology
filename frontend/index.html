<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE-Archaeology Framework - Archaeological Discovery Platform</title>
    
    <!-- Google OAuth -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Material Design Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="css/status-enhancements.css">
    <link rel="stylesheet" href="css/visualization-enhancements.css">
    
    <style>
        :root {
            --discovery-panel-width: 320px;
            --chat-panel-width: 320px;
            --header-height: 70px;
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --border-color: #404040;
            --accent-color: #00ff88;
            --text-primary: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        /* Header - Fixed at top */
        .app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            height: var(--header-height);
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 1.5rem;
            z-index: 2000;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .header-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .site-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }
        
        .header-content h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .header-content h1 a {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .header-content h1 a:hover {
            color: var(--accent-color);
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .task-indicator {
            color: var(--accent-color);
            font-size: 0.875rem;
            font-weight: 600;
            min-width: 250px;
            text-align: right;
        }
        
        /* Main content - Full screen below header */
        .main-content {
            position: fixed;
            top: var(--header-height);
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: calc(100vh - var(--header-height));
            overflow: hidden;
        }
        
        /* Map - Full screen background */
        .map-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Discovery Panel - Floating left */
        .discovery-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            width: var(--discovery-panel-width);
            max-height: calc(100vh - var(--header-height) - 120px);
            background: rgba(45, 45, 45, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(64, 64, 64, 0.8);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 1001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .discovery-panel:hover {
            background: rgba(45, 45, 45, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }
        
        .discovery-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(64, 64, 64, 0.6);
            background: rgba(37, 37, 37, 0.8);
            border-radius: 12px 12px 0 0;
        }
        
        .discovery-header h1 {
            font-size: 16px;
            margin-bottom: 4px;
            color: var(--accent-color);
        }
        
        .discovery-header p {
            color: #aaa;
            font-size: 11px;
            margin: 0;
        }
        
        .discovery-controls {
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) var(--bg-primary);
        }
        
        .discovery-controls::-webkit-scrollbar {
            width: 6px;
        }
        
        .discovery-controls::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        .discovery-controls::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        
        .control-group {
            margin-bottom: 12px;
            background: rgba(31, 31, 31, 0.8);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(53, 53, 53, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .control-group h3 {
            font-size: 12px;
            color: var(--accent-color);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group[data-collapsible="true"] h3 {
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }
        
        .control-group[data-collapsible="true"] h3:hover {
            color: var(--accent-color);
        }
        
        .control-group .toggle-icon {
            float: right;
            font-size: 12px;
            transition: transform 0.2s ease;
        }
        
        .control-group.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        
        .control-group .control-content {
            transition: max-height 0.3s ease;
            overflow: hidden;
        }
        
        .control-group.collapsed .control-content {
            max-height: 0;
            opacity: 0.5;
        }
        
        .input-group {
            margin-bottom: 8px;
        }
        
        .input-group label {
            display: block;
            font-size: 11px;
            color: #ccc;
            margin-bottom: 3px;
        }
        
        .input-group input,
        .input-group select {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        
        .btn {
            padding: 8px 14px;
            background: var(--accent-color);
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn:hover {
            background: #00cc6a;
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            background: var(--border-color);
            color: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        .btn-stop {
            background: #ff4444;
            color: var(--text-primary);
        }
        
        .btn-stop:hover {
            background: #cc3333;
        }
        
        .btn-test {
            background: #ff6b35;
            border-color: #ff6b35;
        }
        
        .btn-test:hover {
            background: #e55a2b;
            border-color: #e55a2b;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .button-grid .btn:first-child {
            grid-column: 1 / -1;
        }
        
        .button-grid .btn:nth-child(4) {
            grid-column: 1 / -1;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        .discovery-status {
            padding: 12px 16px;
            background: rgba(37, 37, 37, 0.8);
            border-top: 1px solid rgba(64, 64, 64, 0.6);
            border-radius: 0 0 12px 12px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }
        
        .status-value {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        /* Chat Panel - Floating right */
        .chat-panel {
            position: absolute;
            bottom: 20px; /* Adjusted to move it higher */
            right: 20px;
            width: var(--chat-panel-width);
            max-height: calc(100vh - var(--header-height) - 40px);
            background: rgba(45, 45, 45, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(64, 64, 64, 0.8);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 1001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .chat-panel:hover {
            background: rgba(45, 45, 45, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }
        
        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(64, 64, 64, 0.6);
            background: rgba(37, 37, 37, 0.8);
            border-radius: 12px 12px 0 0;
        }
        
        .chat-header h5 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        
        .chat-header small {
            color: #aaa;
            font-size: 0.875rem;
        }
        
        .auth-section {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
        }
        
        .login-prompt {
            color: #aaa;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .chat-welcome {
            text-align: center;
            color: #aaa;
            font-size: 0.9rem;
        }
        
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            max-width: 85%;
        }
        
        .message.user {
            background-color: #007bff;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .message.ai {
            background-color: #3a3a3a;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .message-content {
            margin-bottom: 0.25rem;
            line-height: 1.4;
        }
        
        .message-time {
            font-size: 0.75rem;
            opacity: 0.7;
        }
        
        .chat-input-section {
            border-top: 1px solid var(--border-color);
            padding: 1rem;
            background-color: var(--bg-secondary);
        }
        
        .chat-input-container {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }
        
        .chat-input-container input {
            flex: 1;
            min-width: 0;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.875rem;
        }
        
        .chat-input-container input:focus {
            outline: none;
            border-color: #007bff;
        }
        
        .chat-input-container input::placeholder {
            color: #666;
        }
        
        .chat-input-container button {
            flex-shrink: 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .chat-input-container button:hover:not(:disabled) {
            background: #0056b3;
        }
        
        .chat-input-container button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
        }
        
        .user-profile-section {
            border-top: 1px solid var(--border-color);
            padding: 0.75rem;
            background-color: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .user-profile-bottom {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
        }
        
        .user-details {
            flex: 1;
            min-width: 0;
        }
        
        .user-name {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.8rem;
            margin-bottom: 0.125rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .user-email {
            color: #aaa;
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .oauth-notice {
            margin-top: 0.5rem;
            padding: 0.25rem;
            font-size: 0.75rem;
            color: #666;
            text-align: center;
            opacity: 0.7;
        }
        
        /* Connection status overlay */
        .connection-status {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 6px 10px;
            border-radius: 16px;
            font-size: 11px;
            z-index: 1200;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
            font-weight: 600;
        }
        
        .connection-status.connected {
            background: rgba(0, 255, 136, 0.25);
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.25);
            border: 1px solid #ff4444;
            color: #ff4444;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
        }
        
        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        
        .scan-animation {
            animation: scanPulse 1.5s ease-out forwards;
        }
        
        @keyframes scanPulse {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            :root {
                --discovery-panel-width: 280px;
                --chat-panel-width: 280px;
            }
        }
        
        @media (max-width: 900px) {
            :root {
                --discovery-panel-width: 250px;
                --chat-panel-width: 250px;
            }
        }
        
        @media (max-width: 600px) {
            .discovery-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                width: calc(100vw - 20px);
                max-height: 200px;
            }
            
            .chat-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                top: auto;
                width: calc(100vw - 20px);
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="app-header">
        <div class="header-content">
            <div class="header-logo">
                <img src="images/site-logo.svg" alt="RE-Archaeology" class="site-logo">
                <h1><a href="#" onclick="window.unifiedApp.goToHomepage(); return false;">RE-Archaeology Framework</a></h1>
            </div>
            <div class="header-actions">
                <div class="task-indicator">
                    <span id="scanningStatusIndicator">Status: Ready</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main content -->
    <div class="main-content">
        <!-- Map Container (Full screen background) -->
        <div class="map-container">
            <div id="map"></div>
            
            <!-- Connection Status -->
            <div class="connection-status disconnected" id="connectionStatus">
                <div class="connection-dot"></div>
                <span>Disconnected</span>
            </div>
        </div>
        
        <!-- Discovery Panel (Floating Left) -->
        <div class="discovery-panel">
            <div class="discovery-header">
                <h1>🏛️ Structure Discovery</h1>
                <p>Real-time archaeological structure detection using φ⁰-ψ⁰ resonance analysis</p>
            </div>
            
            <div class="discovery-controls">
                <!-- Region Selection -->
                <div class="control-group" data-collapsible="true">
                    <h3 onclick="toggleControlGroup(this)">🗺️ Scan Region <span class="toggle-icon">▼</span></h3>
                    <div class="control-content">
                        <div class="input-group">
                            <label>Center Latitude</label>
                            <input type="number" id="centerLat" value="52.4751" step="0.0001">
                        </div>
                        <div class="input-group">
                            <label>Center Longitude</label>
                            <input type="number" id="centerLon" value="4.8156" step="0.0001">
                        </div>
                        <div class="input-group">
                            <label>Scan Radius (km)</label>
                            <input type="number" id="scanRadius" value="2" step="0.5" min="0.5" max="10">
                        </div>
                        <div class="input-group">
                            <label>Patch Size (m)</label>
                            <input type="number" id="patchSize" value="40" step="16" min="32" max="256">
                        </div>
                    </div>
                </div>
                
                <!-- Detection Settings -->
                <div class="control-group" data-collapsible="true">
                    <h3 onclick="toggleControlGroup(this)">🎯 Detection Settings <span class="toggle-icon">▼</span></h3>
                    <div class="control-content">
                        <div class="input-group">
                            <label>φ⁰ Threshold</label>
                            <input type="number" id="phi0Threshold" value="0.35" step="0.05" min="0" max="1">
                        </div>
                        <div class="input-group">
                            <label>ψ⁰ Threshold</label>
                            <input type="number" id="psi0Threshold" value="0.4" step="0.05" min="0" max="1">
                        </div>
                        <div class="input-group">
                            <label>Detection Mode</label>
                            <select id="detectionMode">
                                <option value="windmill" selected>Windmill Structures</option>
                                <option value="tower">Tower Structures</option>
                                <option value="mound">Archaeological Mounds</option>
                                <option value="generic">Generic Structures</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="control-group">
                    <h3>🚀 Actions</h3>
                    <div class="button-grid">
                        <button class="btn btn-primary" id="startScanBtn">Start Scan</button>
                        <button class="btn btn-stop" id="stopScanBtn" disabled>Stop</button>
                        <button class="btn btn-secondary" id="clearResultsBtn">Clear</button>

                    </div>
                </div>
                
                <!-- Visualization Options -->
                <div class="control-group" data-collapsible="true">
                    <h3 onclick="toggleControlGroup(this)">👁️ Visualization <span class="toggle-icon">▼</span></h3>
                    <div class="control-content">
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="showElevation" checked> Show elevation data
                            </label>
                        </div>
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="showConfidence" checked> Color by confidence
                            </label>
                        </div>
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="showScanAnimation"> Show scan animation
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Discovery Status -->
            <div class="discovery-status">
                <div class="status-item">
                    <span>Session:</span>
                    <span class="status-value" id="sessionStatus">Idle</span>
                </div>
                <div class="status-item">
                    <span>Processed:</span>
                    <span class="status-value" id="processedPatches">0</span>
                </div>
                <div class="status-item">
                    <span>Detections:</span>
                    <span class="status-value" id="totalDetections">0</span>
                </div>
                <div class="status-item">
                    <span>High Confidence:</span>
                    <span class="status-value" id="highConfidenceDetections">0</span>
                </div>
                <div class="status-item">
                    <span>Kernel Status:</span>
                    <span class="status-value" id="kernelStatus">Unknown</span>
                </div>
            </div>
        </div>
        
        <!-- Chat Panel (Floating Right) -->
        <div class="chat-panel">
            <header class="chat-header">
                <h5 class="mb-0">👩‍🔬 Bella</h5>
                <small>Guardian of Civilizations</small>
            </header>
            
            <!-- Authentication - Login Only -->
            <section class="auth-section" id="login-section">
                <p class="login-prompt">Sign in to chat with Bella</p>
                <!-- Google OAuth -->
                <div id="g_id_onload"
                     data-client_id="555743158084-ribsom4oerhv0jgohosoit190p8bh72n.apps.googleusercontent.com"
                     data-callback="handleGoogleLogin"
                     data-error_callback="handleGoogleError"
                     data-auto_prompt="false"
                     data-cancel_on_tap_outside="false"
                     data-use_fedcm_for_prompt="false">
                </div>
                <div class="g_id_signin" 
                     data-type="standard" 
                     data-size="medium" 
                     data-theme="outline" 
                     data-text="sign_in_with">
                </div>
        
                <!-- OAuth Configuration Notice -->
                <div id="oauth-config-notice" class="oauth-notice" style="display: none;">
                    <small class="text-muted">
                        <i>⚠️ OAuth configuration needed for production use</i>
                    </small>
                </div>
            </section>
            
            <!-- Chat Messages -->
            <section class="chat-messages" id="chat-messages">
                <div class="chat-welcome" id="chat-welcome">
                    <p>👋 Hi! I'm Bella, your AI assistant for RE-Archaeology.</p>
                    <p class="small">Sign in to start our conversation!</p>
                </div>
            </section>
            
            <!-- Chat Input -->
            <section class="chat-input-section">
                <form id="chat-input-form" class="chat-input-container" style="display: none;">
                    <input type="text" 
                           id="chat-input" 
                           class="form-control" 
                           placeholder="Ask Bella about discoveries..." 
                           disabled>
                    <button type="submit" id="send-btn" class="btn btn-primary" disabled>
                        Send
                    </button>
                </form>
            </section>
            
            <!-- User Profile - Bottom -->
            <section class="user-profile-section" id="user-profile" style="display: none;">
                <div class="user-profile-bottom">
                    <img id="user-avatar" class="user-avatar" src="" alt="">
                    <div class="user-details">
                        <div id="user-name" class="user-name"></div>
                        <div id="user-email" class="user-email text-muted small"></div>
                    </div>
                    <button id="logout-btn" class="btn btn-sm btn-outline-secondary" style="display: none;">
                        Logout
                    </button>
                </div>
            </section>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Application Configuration -->
    <script>
        // Global configuration
        window.AppConfig = {
            googleClientId: '555743158084-ribsom4oerhv0jgohosoit190p8bh72n.apps.googleusercontent.com',
            apiBase: '/api/v1',
            log() {
                console.log('%c🔧 RE-Archaeology Configuration', 'color: #2563eb; font-weight: bold; font-size: 14px;');
                console.log(`%c   Google Client ID: %c${this.googleClientId}`, 'color: #64748b;', 'color: #0f172a;');
                console.log(`%c   API Base: %c${this.apiBase}`, 'color: #64748b;', 'color: #0f172a;');
                console.log(`%c   Current Origin: %c${window.location.origin}`, 'color: #64748b;', 'color: #0f172a;');
            }
        };
    </script>
    
    <!-- Discovery API -->
    <script src="js/discovery-api.js"></script>
    <!-- Enhanced Status Management -->
    <script src="js/status-manager.js"></script>
    <script src="js/status-ui-manager.js"></script>
    <!-- Patch Visualization -->        <script src="js/patch-visualization.js?v=13.2"></script>
    
    <!-- Main Application -->
    <script>
        // Unified Application Class
        class UnifiedREArchaeologyApp {
            constructor() {
                // Initialize both discovery and chat functionality
                this.currentUser = null;
                this.isAuthenticated = false;
                this.apiBase = window.AppConfig ? window.AppConfig.apiBase : '/api/v1';
                
                // Discovery functionality
                this.statusManager = new StatusManager();
                this.statusUI = new StatusUIManager(this.statusManager);
                this.map = null;
                this.isScanning = false;
                this.currentSession = null;
                this.patches = new Map();
                this.scanAreaCircle = null;
                
                this.init();
            }
            
            async init() {
                try {
                    console.log('Initializing unified RE-Archaeology app...');
                    
                    // Initialize discovery components
                    await this.initDiscovery();
                    
                    // Initialize chat components
                    this.initChat();
                    
                    // Setup authentication
                    this.checkAuthState();
                    
                    console.log('✅ Unified app initialized successfully');
                } catch (error) {
                    console.error('❌ Failed to initialize unified app:', error);
                }
            }
            
            async initDiscovery() {
                // Initialize map
                this.initMap();
                
                // Initialize patch visualization
                this.initPatchVisualization();
                
                // Setup discovery event handlers
                this.setupDiscoveryEvents();
                
                // Try to connect to WebSocket
                try {
                    await this.statusManager.connect();
                    console.log('✅ Discovery WebSocket connected');
                } catch (error) {
                    console.warn('⚠️ Discovery running in offline mode:', error.message);
                    this.setupOfflineMode();
                }
            }

            initPatchVisualization() {
                // Initialize patch visualization system
                if (typeof PatchVisualization !== 'undefined') {
                    this.patchViz = new PatchVisualization();
                    window.patchViz = this.patchViz; // Make globally accessible
                    console.log('✅ Patch visualization initialized');
                } else {
                    console.warn('⚠️ PatchVisualization class not found');
                }
            }
            
            initMap() {
                // Initialize the map
                this.map = L.map('map').setView([52.4751, 4.8156], 13);
                
                // Add base layer (satellite)
                this.satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri'
                }).addTo(this.map);
                
                // Add street layer (initially hidden)
                this.streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                });
                
                // Add LiDAR elevation overlay for Netherlands region
                this.lidarLayer = L.tileLayer('https://service.pdok.nl/rce/ahn/wmts/ahn4_05m_dsm/EPSG:3857/{z}/{x}/{y}.png', {
                    attribution: 'AHN4 LiDAR &copy; PDOK',
                    opacity: 0.6,
                    maxZoom: 16
                });
                
                // Add layer control
                const baseLayers = {
                    'Satellite': this.satelliteLayer,
                    'Street Map': this.streetLayer
                };
                
                const overlayLayers = {
                    'LiDAR Elevation (AHN4)': this.lidarLayer
                };
                
                L.control.layers(baseLayers, overlayLayers).addTo(this.map);
                
                // Add scan area circle
                this.scanAreaCircle = L.circle([52.4751, 4.8156], {
                    color: '#00ff88',
                    fillColor: '#00ff88',
                    fillOpacity: 0.1,
                    radius: 2000
                }).addTo(this.map);
                
                // Handle map clicks for setting scan center
                this.map.on('click', (e) => {
                    if (!this.isScanning) {
                        document.getElementById('centerLat').value = e.latlng.lat.toFixed(6);
                        document.getElementById('centerLon').value = e.latlng.lng.toFixed(6);
                        this.updateScanArea();
                    }
                });
                
                this.updateScanArea();
            }
            
            setupDiscoveryEvents() {
                // Button events
                document.getElementById('startScanBtn').addEventListener('click', () => this.startScan());
                document.getElementById('stopScanBtn').addEventListener('click', () => this.stopScan());
                document.getElementById('clearResultsBtn').addEventListener('click', () => this.clearResults());
                
                // Input events
                document.getElementById('centerLat').addEventListener('change', () => this.updateScanArea());
                document.getElementById('centerLon').addEventListener('change', () => this.updateScanArea());
                document.getElementById('scanRadius').addEventListener('change', () => this.updateScanArea());
                
                // Status manager events
                this.statusManager.on('connectionEstablished', () => {
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('connectionStatus').innerHTML = '<div class="connection-dot"></div><span>Connected</span>';
                    document.getElementById('startScanBtn').disabled = false;
                });
                
                this.statusManager.on('disconnected', () => {
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('connectionStatus').innerHTML = '<div class="connection-dot"></div><span>Disconnected</span>';
                    document.getElementById('startScanBtn').disabled = true;
                    document.getElementById('stopScanBtn').disabled = true;
                });
                
                this.statusManager.on('sessionStarted', (session) => {
                    this.currentSession = session;
                    this.isScanning = true;
                    document.getElementById('sessionStatus').textContent = 'Scanning';
                    document.getElementById('scanningStatusIndicator').textContent = 'Scanning: 0% (0/0) • Initializing...';
                });
                
                this.statusManager.on('sessionCompleted', () => {
                    this.isScanning = false;
                    this.currentSession = null;
                    document.getElementById('sessionStatus').textContent = 'Completed';
                    document.getElementById('scanningStatusIndicator').textContent = 'Status: Completed';
                });
                
                this.statusManager.on('patchResult', (patch) => {
                    this.handlePatchUpdate(patch);
                    
                    // Update progress in header status with detailed information
                    if (this.isScanning && this.statusManager.state?.progress) {
                        const progress = this.statusManager.state.progress;
                        const percentage = Math.round(progress.percentage || 0);
                        const current = progress.current || 0;
                        const total = progress.total || 0;
                        const rate = progress.rate ? Math.round(progress.rate * 10) / 10 : 0;
                        const eta = progress.eta;
                        
                        let statusText = `Scanning: ${percentage}% (${current}/${total})`;
                        if (rate > 0) {
                            statusText += ` • ${rate}/s`;
                        }
                        if (eta) {
                            const etaMinutes = Math.round(eta / 60);
                            if (etaMinutes > 0) {
                                statusText += ` • ETA: ${etaMinutes}m`;
                            }
                        }
                        
                        document.getElementById('scanningStatusIndicator').textContent = statusText;
                    }
                    
                    // Show scan animation if enabled
                    if (document.getElementById('showScanAnimation')?.checked) {
                        this.showScanAnimation(patch.lat, patch.lon);
                    }
                });
                
                // Listen for periodic status updates to refresh progress display
                this.statusManager.on('statusUpdate', (status) => {
                    if (this.isScanning && status.progress) {
                        const progress = status.progress;
                        const percentage = Math.round(progress.percentage || 0);
                        const current = progress.current || 0;
                        const total = progress.total || 0;
                        const rate = progress.rate ? Math.round(progress.rate * 10) / 10 : 0;
                        const eta = progress.eta;
                        
                        let statusText = `Scanning: ${percentage}% (${current}/${total})`;
                        if (rate > 0) {
                            statusText += ` • ${rate}/s`;
                        }
                        if (eta) {
                            const etaMinutes = Math.round(eta / 60);
                            if (etaMinutes > 0) {
                                statusText += ` • ETA: ${etaMinutes}m`;
                            }
                        }
                        
                        document.getElementById('scanningStatusIndicator').textContent = statusText;
                    }
                });
            }
            
            setupOfflineMode() {
                // Disable features that require WebSocket connection
                document.getElementById('startScanBtn').disabled = true;
                document.getElementById('stopScanBtn').disabled = true;
                document.getElementById('sessionStatus').textContent = 'Offline Mode';
                document.getElementById('scanningStatusIndicator').textContent = 'Status: Offline';
            }
            
            updateScanArea() {
                const lat = parseFloat(document.getElementById('centerLat').value);
                const lon = parseFloat(document.getElementById('centerLon').value);
                const radius = parseFloat(document.getElementById('scanRadius').value) * 1000;
                
                this.scanAreaCircle.setLatLng([lat, lon]);
                this.scanAreaCircle.setRadius(radius);
                this.map.setView([lat, lon], this.map.getZoom());
            }
            
            async startScan() {
                if (this.isScanning || !this.statusManager.isConnected()) {
                    console.warn('Cannot start scan: already scanning or not connected');
                    return;
                }
                
                // Clear any previous results
                this.clearResults();
                
                const config = {
                    center_lat: parseFloat(document.getElementById('centerLat').value),
                    center_lon: parseFloat(document.getElementById('centerLon').value),
                    scan_radius_km: parseFloat(document.getElementById('scanRadius').value),
                    patch_size_m: parseInt(document.getElementById('patchSize').value),
                    phi0_threshold: parseFloat(document.getElementById('phi0Threshold').value),
                    psi0_threshold: parseFloat(document.getElementById('psi0Threshold').value),
                    detection_mode: document.getElementById('detectionMode').value
                };
                
                try {
                    console.log('🚀 Starting new discovery session with config:', config);
                    await this.statusManager.startDiscovery(config);
                } catch (error) {
                    console.error('Failed to start scan:', error);
                    alert('Failed to start scan: ' + error.message);
                }
            }
            
            async stopScan() {
                if (!this.statusManager.isConnected()) {
                    return;
                }
                
                try {
                    await this.statusManager.stopDiscovery(this.currentSession?.session_id);
                } catch (error) {
                    console.error('Failed to stop scan:', error);
                }
            }
            
            async clearResults() {
                try {
                    // Clear backend sessions if connected
                    if (this.statusManager.isConnected()) {
                        await this.statusManager.clearSessions();
                    }
                } catch (error) {
                    console.warn('Failed to clear backend sessions:', error);
                }
                
                // Remove all patch layers from map
                this.patches.forEach(patch => {
                    if (patch.mapElement) {
                        this.map.removeLayer(patch.mapElement);
                    }
                });
                
                this.patches.clear();
                
                // Reset session state
                this.currentSession = null;
                this.isScanning = false;
                
                // Reset UI state
                document.getElementById('sessionStatus').textContent = 'Idle';
                document.getElementById('scanningStatusIndicator').textContent = 'Status: Ready';
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('stopScanBtn').disabled = true;
                
                // Reset counters
                document.getElementById('processedPatches').textContent = '0';
                document.getElementById('totalDetections').textContent = '0';
                document.getElementById('highConfidenceDetections').textContent = '0';
                
                // Hide any patch details
                const patchGrid = document.getElementById('patchGrid');
                if (patchGrid) {
                    patchGrid.style.display = 'none';
                }
                
                // Only reset status manager state without disconnecting WebSocket
                // This prevents WebSocket disconnection during active discovery sessions
                this.statusManager.updateState({
                    session: null,
                    scanning: false,
                    progress: {
                        current: 0,
                        total: 0,
                        percentage: 0,
                        rate: 0,
                        eta: null
                    },
                    statistics: {
                        totalPatches: 0,
                        positiveDetections: 0,
                        highConfidenceDetections: 0,
                        averageConfidence: 0,
                        scanStartTime: null,
                        lastUpdateTime: null
                    },
                    errors: []
                });
                
                console.log('✅ Session cleared and UI reset (WebSocket connection preserved)');
            }
            
            handlePatchUpdate(patch) {
                this.patches.set(patch.patch_id, patch);
                this.addPatchToMap(patch);
                
                // Update counters
                document.getElementById('processedPatches').textContent = this.patches.size;
                
                const positivePatches = Array.from(this.patches.values()).filter(p => p.is_positive);
                document.getElementById('totalDetections').textContent = positivePatches.length;
                
                const highConfidencePatches = positivePatches.filter(p => (p.confidence || 0) >= 0.8);
                document.getElementById('highConfidenceDetections').textContent = highConfidencePatches.length;
            }
            
            addPatchToMap(patch) {
                const bounds = this.getPatchBounds(patch);
                const color = this.getPatchColor(patch);
                
                const rectangle = L.rectangle(bounds, {
                    color: color,
                    weight: 1,
                    fillColor: color,
                    fillOpacity: patch.is_positive ? 0.7 : 0.3
                }).addTo(this.map);
                
                // Add popup with professional analyzer-style visualization
                rectangle.bindPopup(`
                    <div class="patch-popup professional" style="width: 400px;">
                        <div class="popup-header" style="background: #252525; padding: 12px; margin: -20px -20px 15px -20px; border-radius: 8px 8px 0 0;">
                            <h4 style="color: #00ff88; margin: 0; font-size: 14px;">Patch ${patch.patch_id} Analysis</h4>
                            <div style="color: #ccc; font-size: 11px; margin-top: 4px;">
                                📍 ${patch.lat.toFixed(4)}, ${patch.lon.toFixed(4)} • 
                                Score: <span style="color: ${this.getScoreColor(patch.confidence || 0)}">${((patch.confidence || 0) * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                        
                        <div class="popup-metrics" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px;">
                            <div style="background: #1a1a1a; padding: 8px; border-radius: 4px; border-left: 3px solid #00ff88;">
                                <div style="color: #ccc; font-size: 10px;">φ⁰ SCORE</div>
                                <div style="color: #fff; font-size: 12px; font-weight: bold;">${patch.detection_result?.phi0?.toFixed(3) || 'N/A'}</div>
                            </div>
                            <div style="background: #1a1a1a; padding: 8px; border-radius: 4px; border-left: 3px solid #ff9f40;">
                                <div style="color: #ccc; font-size: 10px;">ψ⁰ SCORE</div>
                                <div style="color: #fff; font-size: 12px; font-weight: bold;">${patch.detection_result?.psi0?.toFixed(3) || 'N/A'}</div>
                            </div>
                        </div>
                        
                        <div class="popup-visualization" style="display: flex; gap: 15px;">
                            <!-- Elevation Heatmap -->
                            <div style="flex: 1;">
                                <h6 style="color: #ccc; margin: 0 0 8px 0; font-size: 11px; text-align: center;">Elevation Pattern</h6>
                                <div id="miniElevationGrid_${patch.patch_id}" class="mini-elevation-grid professional" 
                                     style="display: flex; flex-direction: column; align-items: center; width: 120px; margin: 0 auto;">
                                    <!-- Will be populated with canvas heatmap by JavaScript -->
                                </div>
                            </div>
                            
                            <!-- Professional Histogram -->
                            <div style="flex: 1;">
                                <h6 style="color: #ccc; margin: 0 0 8px 0; font-size: 11px; text-align: center;">Elevation Distribution</h6>
                                <div id="miniHistogram_${patch.patch_id}" style="width: 180px; height: 120px; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; position: relative;">
                                    <canvas width="180" height="120" style="display: block;"></canvas>
                                </div>
                            </div>
                        </div>
                        
                        <div class="popup-status" style="margin-top: 15px; text-align: center; padding: 8px; background: ${patch.is_positive ? 'rgba(0, 255, 136, 0.1)' : 'rgba(102, 102, 102, 0.1)'}; border-radius: 4px;">
                            <span style="color: ${patch.is_positive ? '#00ff88' : '#666'}; font-size: 12px; font-weight: bold;">
                                ${patch.is_positive ? '🎯 POSITIVE DETECTION' : '❌ NEGATIVE'}
                            </span>
                        </div>
                    </div>
                `, {
                    maxWidth: 450,
                    minWidth: 420,
                    className: 'professional-popup'
                });
                
                // Add click handler to show professional visualizations in popup ONLY
                rectangle.on('click', () => {
                    // Small delay to ensure popup is rendered
                    setTimeout(() => {
                        this.showProfessionalVisualizationInPopup(patch);
                    }, 100);
                });
                
                patch.mapElement = rectangle;
            }
            
            getPatchBounds(patch) {
                // Use the actual patch size from the patch data, or fall back to UI setting
                const patchSizeM = patch.patch_size_m || parseInt(document.getElementById('patchSize').value) || 40;
                const patchSizeKm = patchSizeM / 1000;
                
                // Convert patch size to degrees (more accurate calculation)
                const latOffset = patchSizeKm / 111.32; // 1 degree latitude = ~111.32 km
                const lonOffset = patchSizeKm / (111.32 * Math.cos(patch.lat * Math.PI / 180));
                
                return [
                    [patch.lat - latOffset/2, patch.lon - lonOffset/2],
                    [patch.lat + latOffset/2, patch.lon + lonOffset/2]
                ];
            }
            
            getPatchColor(patch) {
                if (!patch.is_positive) {
                    return '#666666';
                }
                
                const confidence = patch.confidence || 0;
                if (confidence >= 0.8) return '#ff4444';
                if (confidence >= 0.6) return '#ffaa00';
                if (confidence >= 0.4) return '#ffff00';
                return '#00ff88';
            }
            
            getScoreColor(score) {
                if (score >= 0.7) return '#00ff88'; // Green
                if (score >= 0.4) return '#ffaa00'; // Orange
                return '#ff4444'; // Red
            }
            
            showProfessionalVisualizationInPopup(patch) {
                console.log('🎨 Creating professional popup visualization for patch:', patch.patch_id);
                
                // Populate professional elevation grid
                this.populateProfessionalElevationGrid(patch);
                
                // Populate professional histogram with Chart.js
                this.populateProfessionalHistogram(patch);
            }
            
            populateProfessionalElevationGrid(patch) {
                const gridElement = document.getElementById(`miniElevationGrid_${patch.patch_id}`);
                if (!gridElement || !patch.elevation_data) return;
                
                const data = patch.elevation_data;
                const rows = data.length;
                const cols = data[0]?.length || 0;
                
                if (rows === 0 || cols === 0) return;
                
                // Create canvas for smooth heatmap (like matplotlib)
                const canvas = document.createElement('canvas');
                const targetSize = 120; // Target display size
                canvas.width = targetSize;
                canvas.height = targetSize;
                canvas.style.cssText = `
                    border: 1px solid #444;
                    border-radius: 4px;
                    image-rendering: auto; /* Smooth interpolation */
                    background: #f0f8ff;
                `;
                
                const ctx = canvas.getContext('2d');
                
                // Calculate statistics
                const stats = patch.elevation_stats || this.calculateElevationStats(data);
                const min = stats.min;
                const max = stats.max;
                const range = max - min;
                
                console.log(`Creating heatmap: ${rows}x${cols} data, range: ${min.toFixed(2)}-${max.toFixed(2)}m`);
                
                if (range === 0) {
                    // Flat terrain - single color
                    ctx.fillStyle = this.getElevationColor(0.5);
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    // Create smooth heatmap using canvas scaling
                    // First, create a high-resolution version
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = cols;
                    tempCanvas.height = rows;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Create ImageData for direct pixel manipulation
                    const imageData = tempCtx.createImageData(cols, rows);
                    const pixelData = imageData.data;
                    
                    // Fill pixel data with elevation colors
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            const value = data[i][j];
                            let r = 240, g = 248, b = 255; // Default light blue
                            
                            if (value !== null && value !== undefined && !isNaN(value)) {
                                const normalized = (value - min) / range;
                                const colorStr = this.getElevationColor(normalized);
                                
                                // Parse RGB values from string like "rgb(51, 102, 153)"
                                const rgbMatch = colorStr.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                                if (rgbMatch) {
                                    r = parseInt(rgbMatch[1]);
                                    g = parseInt(rgbMatch[2]);
                                    b = parseInt(rgbMatch[3]);
                                }
                            }
                            
                            const pixelIndex = (i * cols + j) * 4;
                            pixelData[pixelIndex] = r;     // Red
                            pixelData[pixelIndex + 1] = g; // Green
                            pixelData[pixelIndex + 2] = b; // Blue
                            pixelData[pixelIndex + 3] = 255; // Alpha
                        }
                    }
                    
                    // Put the image data to temp canvas
                    tempCtx.putImageData(imageData, 0, 0);
                    
                    // Scale and draw to final canvas with smooth interpolation
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(tempCanvas, 0, 0, cols, rows, 0, 0, canvas.width, canvas.height);
                }
                
                // Clear grid and add canvas
                gridElement.innerHTML = '';
                
                // Add title
                const title = document.createElement('div');
                title.style.cssText = `
                    font-size: 11px; 
                    color: #ccc; 
                    text-align: center; 
                    margin-bottom: 5px;
                    font-weight: bold;
                `;
                title.textContent = `Elevation Heatmap (${rows}×${cols}) - Terrain Colors`;
                gridElement.appendChild(title);
                
                // Add the canvas
                gridElement.appendChild(canvas);
                
                // Add elevation range info
                const rangeInfo = document.createElement('div');
                rangeInfo.style.cssText = `
                    font-size: 10px; 
                    color: #999; 
                    text-align: center; 
                    margin-top: 3px;
                `;
                rangeInfo.textContent = `${min.toFixed(1)}m - ${max.toFixed(1)}m`;
                gridElement.appendChild(rangeInfo);
            }
            
            populateProfessionalHistogram(patch) {
                const histogramElement = document.getElementById(`miniHistogram_${patch.patch_id}`);
                const canvas = histogramElement?.querySelector('canvas');
                if (!canvas || !patch.elevation_data) return;
                
                // Check if Chart.js is available
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not available, using canvas fallback');
                    this.drawCanvasHistogram(canvas, patch);
                    return;
                }
                
                // Calculate histogram data
                const histogramData = this.calculateSimpleHistogramData(patch);
                
                const ctx = canvas.getContext('2d');
                
                // Create professional Chart.js histogram
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: histogramData.binLabels,
                        datasets: [{
                            label: 'Local',
                            data: histogramData.localDensity,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }, {
                            label: 'Expected',
                            data: histogramData.kernelDensity,
                            backgroundColor: 'rgba(255, 159, 64, 0.7)',
                            borderColor: 'rgba(255, 159, 64, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: '#ccc',
                                    font: { size: 10 }
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#ccc', font: { size: 8 } },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                ticks: { color: '#ccc', font: { size: 8 } },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            calculateSimpleHistogramData(patch) {
                const elevationValues = patch.elevation_data
                    .flat()
                    .filter(v => v !== null && v !== undefined && !isNaN(v));
                
                const stats = patch.elevation_stats || this.calculateElevationStats(patch.elevation_data);
                const numBins = 8;
                const binWidth = (stats.max - stats.min) / numBins;
                
                const localBins = Array(numBins).fill(0);
                elevationValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - stats.min) / binWidth), numBins - 1);
                    if (binIndex >= 0) localBins[binIndex]++;
                });
                
                const totalCount = elevationValues.length;
                const localDensity = localBins.map(count => count / totalCount);
                
                // Generate expected windmill pattern
                const kernelDensity = Array(numBins).fill(0);
                for (let i = 0; i < numBins; i++) {
                    const normalized = i / (numBins - 1);
                    if (normalized < 0.3) kernelDensity[i] = 0.05;
                    else if (normalized < 0.7) kernelDensity[i] = 0.2;
                    else kernelDensity[i] = 0.1;
                }
                
                return {
                    localDensity,
                    kernelDensity,
                    binLabels: localBins.map((_, i) => {
                        const start = stats.min + i * binWidth;
                        return `${start.toFixed(1)}m`;
                    })
                };
            }
            
            // Chat functionality
            initChat() {
                this.setupChatEventListeners();
            }
            
            setupChatEventListeners() {
                const chatInput = document.getElementById('chat-input');
                const sendBtn = document.getElementById('send-btn');
                const chatInputForm = document.getElementById('chat-input-form');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (chatInput && sendBtn) {
                    chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey && !chatInput.disabled) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });
                    sendBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.sendMessage();
                    });
                }
                
                if (chatInputForm) {
                    chatInputForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.sendMessage();
                    });
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.logout());
                }
            }
            
            // Authentication
            checkAuthState() {
                const token = localStorage.getItem('auth_token');
                if (token) {
                    this.validateToken(token);
                }
            }
            
            async validateToken(token) {
                try {
                    const response = await fetch(`${this.apiBase}/auth/validate`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });
                    
                    if (response.ok) {
                        const userData = await response.json();
                        this.currentUser = userData.user || userData; // Handle both response formats
                        this.setAuthenticatedState(true);
                    } else {
                        localStorage.removeItem('auth_token');
                        this.setAuthenticatedState(false);
                    }
                } catch (error) {
                    console.error('Token validation error:', error);
                    localStorage.removeItem('auth_token');
                    this.setAuthenticatedState(false);
                }
            }
            
            async handleGoogleLogin(response) {
                try {
                    const authResponse = await fetch(`${this.apiBase}/auth/google`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            token: response.credential
                        })
                    });
                    
                    if (authResponse.ok) {
                        const data = await authResponse.json();
                        localStorage.setItem('auth_token', data.access_token);
                        this.currentUser = data.user;
                        this.setAuthenticatedState(true);
                        
                        // Send welcome message from Bella
                        this.addChatMessage('ai', `Hello ${data.user.name}! I'm excited to help you explore archaeological discoveries. Feel free to ask me about any findings or start a scan to discover new structures!`);
                    } else {
                        console.error('Google login failed');
                    }
                } catch (error) {
                    console.error('Google login error:', error);
                }
            }
            
            handleGoogleError(error) {
                console.error('Google Sign-In Error:', error);
            }
            
            setAuthenticatedState(isAuth) {
                this.isAuthenticated = isAuth;
                
                const loginSection = document.getElementById('login-section');
                const userProfileSection = document.getElementById('user-profile');
                const chatWelcome = document.getElementById('chat-welcome');
                const chatInputForm = document.getElementById('chat-input-form');
                const chatInput = document.getElementById('chat-input');
                const sendBtn = document.getElementById('send-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (isAuth && this.currentUser) {
                    // Show user profile, hide login
                    loginSection.style.display = 'none';
                    userProfileSection.style.display = 'block';
                    chatWelcome.style.display = 'none';
                    chatInputForm.style.display = 'flex';
                    
                    // Update user info - with debugging
                    console.log('Setting user profile:', this.currentUser);
                    console.log('Available user fields:', Object.keys(this.currentUser));
                    
                    const avatarUrl = this.currentUser.picture || this.currentUser.profile_picture || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiNkZGQiLz4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxMiIgcj0iNSIgZmlsbD0iIzk5OSIvPgo8cGF0aCBkPSJtNCwyNmMwLTYuNjI3LDUuMzczLTEyLDEyLTEyczEyLDUuMzczLDEyLDEyIiBmaWxsPSIjOTk5Ii8+Cjwvc3ZnPgo=';
                    console.log('Avatar URL chosen:', avatarUrl);
                    console.log('Picture field:', this.currentUser.picture);
                    console.log('Profile_picture field:', this.currentUser.profile_picture);
                    
                    const avatarElement = document.getElementById('user-avatar');
                    const nameElement = document.getElementById('user-name');
                    const emailElement = document.getElementById('user-email');
                    
                    if (avatarElement) {
                        avatarElement.src = avatarUrl;
                        avatarElement.onerror = () => {
                            console.warn('Failed to load avatar, using fallback');
                            avatarElement.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1zbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiNkZGQiLz4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxMiIgcj0iNSIgZmlsbD0iIzk5OSIvPgo8cGF0aCBkPSJtNCwyNmMwLTYuNjI3LDUuMzczLTEyLDEyLTEyczEyLDUuMzczLDEyLDEyIiBmaWxsPSIjOTk5Ii8+Cjwvc3ZnPgo=';
                        };
                    }
                    if (nameElement) nameElement.textContent = this.currentUser.name || '';
                    if (emailElement) emailElement.textContent = this.currentUser.email || '';
                    if (logoutBtn) logoutBtn.style.display = 'block';
                    
                    // Enable chat input
                    if (chatInput) chatInput.disabled = false;
                    if (sendBtn) sendBtn.disabled = false;
                } else {
                    // Show login, hide user profile
                    loginSection.style.display = 'block';
                    userProfileSection.style.display = 'none';
                    chatWelcome.style.display = 'block';
                    chatInputForm.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                    
                    // Disable chat input
                    if (chatInput) chatInput.disabled = true;
                    if (sendBtn) sendBtn.disabled = true;
                }
            }
            
            async logout() {
                localStorage.removeItem('auth_token');
                this.currentUser = null;
                this.setAuthenticatedState(false);
                
                // Clear chat messages
                const chatMessages = document.getElementById('chat-messages');
                chatMessages.innerHTML = `
                    <div class="chat-welcome" id="chat-welcome">
                        <p>👋 Hi! I'm Bella, your AI assistant for RE-Archaeology.</p>
                        <p class="small">Sign in to start our conversation!</p>
                    </div>
                `;
            }
            
            // AI Chat
            async sendMessage() {
                const chatInput = document.getElementById('chat-input');
                const message = chatInput.value.trim();
                
                if (!message || !this.isAuthenticated) return;
                
                // Add user message
                this.addChatMessage('user', message);
                chatInput.value = '';
                
                try {
                    const response = await fetch(`${this.apiBase}/ai/message`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
                        },
                        body: JSON.stringify({
                            message: message,
                            context: {
                                current_scan: this.currentSession,
                                total_patches: this.patches.size,
                                positive_detections: Array.from(this.patches.values()).filter(p => p.is_positive).length
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.addChatMessage('ai', data.response);
                    } else {
                        this.addChatMessage('ai', 'Sorry, I encountered an error processing your message.');
                    }
                } catch (error) {
                    console.error('Chat error:', error);
                    this.addChatMessage('ai', 'Sorry, I\'m having trouble connecting right now. Please try again.');
                }
            }
            
            addChatMessage(type, content) {
                const chatMessages = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.innerHTML = `
                    <div class="message-content">${content}</div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                `;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // Utilities
            goToHomepage() {
                // Reset to main discovery interface (homepage)
                this.clearResults();
                document.getElementById('sessionStatus').textContent = 'Ready for Discovery';
                document.getElementById('scanningStatusIndicator').textContent = 'Status: Ready';
                
                // Ensure map is centered on default location
                if (this.map) {
                    this.map.setView([52.4751, 4.8156], 13);
                }
                
                console.log('Returned to main discovery interface (homepage)');
            }
            
            showScanAnimation(lat, lon) {
                // Create a temporary scanning circle animation
                const scanCircle = L.circle([lat, lon], {
                    color: '#00ff88',
                    fillColor: 'transparent',
                    weight: 2,
                    radius: 30,
                    className: 'scan-animation'
                }).addTo(this.map);
                
                // Remove after 1.5 seconds
                setTimeout(() => {
                    this.map.removeLayer(scanCircle);
                }, 1500);
            }

            // Show detailed visualization for a patch
            showPatchDetails(patchId) {
                console.log('🎯 UnifiedApp.showPatchDetails called with patchId:', patchId);
                
                const patch = this.patches.get(patchId);
                if (!patch) {
                    console.warn('❌ Patch not found:', patchId);
                    return;
                }

                console.log('✅ Patch found:', patch.patch_id);
                console.log('✅ Patch has elevation_data:', !!patch.elevation_data);
                
                // Use the patch visualization system
                if (this.patchViz) {
                    console.log('✅ PatchViz system available, calling showPatchDetails');
                    this.patchViz.showPatchDetails(patch);
                } else {
                    console.error('❌ Patch visualization system not initialized');
                }
            }
            
            showMiniVisualizationInPopup(patch) {
                // Populate mini elevation grid
                this.populateMiniElevationGrid(patch);
                
                // Populate mini histogram
                this.populateMiniHistogram(patch);
            }
            
            populateMiniElevationGrid(patch) {
                const gridElement = document.getElementById(`miniElevationGrid_${patch.patch_id}`);
                if (!gridElement || !patch.elevation_data) return;
                
                const data = patch.elevation_data;
                const rows = data.length;
                const cols = data[0]?.length || 0;
                
                if (rows === 0 || cols === 0) return;
                
                // Determine optimal sample size based on available data resolution
                // For AHN4 data (typically 80x80 pixels at 0.5m resolution), we can show more detail
                // Match the 21x21 kernel size used by the detection algorithm when possible
                let sampleSize = 8; // Default fallback
                
                if (rows >= 60 && cols >= 60) {
                    sampleSize = 21; // Full kernel resolution for high-res data
                } else if (rows >= 32 && cols >= 32) {
                    sampleSize = 16; // Medium resolution
                } else if (rows >= 16 && cols >= 16) {
                    sampleSize = 12; // Low-medium resolution
                }
                
                // Update CSS grid to match the sample size
                gridElement.style.gridTemplateColumns = `repeat(${sampleSize}, 1fr)`;
                
                const rowStep = Math.max(1, Math.floor(rows / sampleSize));
                const colStep = Math.max(1, Math.floor(cols / sampleSize));
                
                const stats = patch.elevation_stats || this.calculateElevationStats(data);
                const min = stats.min;
                const max = stats.max;
                const range = max - min;
                
                gridElement.innerHTML = '';
                
                // Add grid info as a data attribute for debugging
                gridElement.setAttribute('data-grid-info', `${sampleSize}x${sampleSize} (from ${rows}x${cols})`);
                
                for (let i = 0; i < sampleSize; i++) {
                    for (let j = 0; j < sampleSize; j++) {
                        const rowIdx = Math.min(i * rowStep, rows - 1);
                        const colIdx = Math.min(j * colStep, cols - 1);
                        const value = data[rowIdx][colIdx];
                        
                        if (value !== null && value !== undefined && !isNaN(value)) {
                            const normalized = range > 0 ? (value - min) / range : 0;
                            
                            const cell = document.createElement('div');
                            cell.className = 'mini-elevation-cell';
                            cell.style.backgroundColor = this.getElevationColor(normalized);
                            cell.title = `${value.toFixed(1)}m @ [${rowIdx},${colIdx}]`;
                            
                            gridElement.appendChild(cell);
                        }
                    }
                }
                
                console.log(`🔍 Mini grid created: ${sampleSize}x${sampleSize} from ${rows}x${cols} source data`);
            }
            
            populateMiniHistogram(patch) {
                const histogramElement = document.getElementById(`miniHistogram_${patch.patch_id}`);
                const canvas = histogramElement?.querySelector('canvas');
                if (!canvas || !patch.elevation_data) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Flatten elevation data
                const elevationValues = patch.elevation_data
                    .flat()
                    .filter(v => v !== null && v !== undefined && !isNaN(v));
                
                if (elevationValues.length === 0) return;
                
                const stats = patch.elevation_stats || this.calculateElevationStats(patch.elevation_data);
                const numBins = 8; // Fewer bins for mini chart
                const binWidth = (stats.max - stats.min) / numBins;
                
                // Create histogram
                const bins = Array(numBins).fill(0);
                elevationValues.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - stats.min) / binWidth), numBins - 1);
                    if (binIndex >= 0) bins[binIndex]++;
                });
                
                const maxCount = Math.max(...bins);
                if (maxCount === 0) return;
                
                // Draw mini histogram
                const barWidth = width / numBins;
                const padding = 2;
                
                ctx.fillStyle = '#00ff88';
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1;
                
                bins.forEach((count, i) => {
                    const barHeight = (count / maxCount) * (height - padding * 2);
                    const x = i * barWidth;
                    const y = height - barHeight - padding;
                    
                    ctx.fillRect(x + 1, y, barWidth - 2, barHeight);
                });
            }
            
            calculateElevationStats(data) {
                const flatData = data.flat().filter(v => v !== null && v !== undefined && !isNaN(v));
                
                if (flatData.length === 0) {
                    return { min: 0, max: 0, mean: 0, std: 0 };
                }

                const min = Math.min(...flatData);
                const max = Math.max(...flatData);
                const mean = flatData.reduce((a, b) => a + b, 0) / flatData.length;
                const variance = flatData.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / flatData.length;
                const std = Math.sqrt(variance);

                return { min, max, mean, std };
            }
            
            getElevationColor(normalized) {
                // Matplotlib terrain colormap approximation
                normalized = Math.max(0, Math.min(1, normalized));
                
                // Matplotlib terrain colormap approximation
                const colors = [
                    { pos: 0.0, color: [51, 102, 153] },    // Deep blue (water/valleys)
                    { pos: 0.15, color: [68, 119, 170] },   // Blue
                    { pos: 0.3, color: [34, 136, 51] },     // Deep green (lowlands)
                    { pos: 0.45, color: [102, 170, 68] },   // Light green (vegetation)
                    { pos: 0.6, color: [170, 170, 68] },    // Yellow-green (hills)
                    { pos: 0.75, color: [204, 153, 102] },  // Brown (exposed earth)
                    { pos: 0.9, color: [238, 221, 204] },   // Light brown (rocky areas)
                    { pos: 1.0, color: [255, 255, 255] }    // White (peaks)
                ];

                // Find the two colors to interpolate between
                let lowerColor = colors[0];
                let upperColor = colors[colors.length - 1];

                for (let i = 0; i < colors.length - 1; i++) {
                    if (normalized >= colors[i].pos && normalized <= colors[i + 1].pos) {
                        lowerColor = colors[i];
                        upperColor = colors[i + 1];
                        break;
                    }
                }

                // Interpolate between the two colors
                const range = upperColor.pos - lowerColor.pos;
                const factor = range === 0 ? 0 : (normalized - lowerColor.pos) / range;

                const r = Math.round(lowerColor.color[0] + factor * (upperColor.color[0] - lowerColor.color[0]));
                const g = Math.round(lowerColor.color[1] + factor * (upperColor.color[1] - lowerColor.color[1]));
                const b = Math.round(lowerColor.color[2] + factor * (upperColor.color[2] - lowerColor.color[2]));

                return `rgb(${r}, ${g}, ${b})`;
            }
        }
        
        // Google OAuth callbacks
        window.handleGoogleLogin = function(response) {
            if (window.unifiedApp) {
                window.unifiedApp.handleGoogleLogin(response);
            }
        };
        
        window.handleGoogleError = function(error) {
            if (window.unifiedApp) {
                window.unifiedApp.handleGoogleError(error);
            } else {
                console.error('Google Sign-In Error:', error);
            }
        };
        
        // Toggle function for collapsible control groups
        window.toggleControlGroup = function(headerElement) {
            const controlGroup = headerElement.parentElement;
            const content = controlGroup.querySelector('.control-content');
            const toggleIcon = headerElement.querySelector('.toggle-icon');
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                toggleIcon.textContent = '▼';
                controlGroup.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                toggleIcon.textContent = '▶';
                controlGroup.classList.add('collapsed');
            }
        };

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Log configuration
            if (window.AppConfig) {
                window.AppConfig.log();
            }
            
            // Update Google OAuth with dynamic client ID
            const googleOnload = document.getElementById('g_id_onload');
            if (googleOnload && window.AppConfig) {
                googleOnload.setAttribute('data-client_id', window.AppConfig.googleClientId);
                googleOnload.setAttribute('data-error_callback', 'handleGoogleError');
            }
            
            window.unifiedApp = new UnifiedREArchaeologyApp();
        });
        
        // Initialize collapsible panels on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize collapsible panels - collapse some by default
            const collapsibleGroups = document.querySelectorAll('.control-group[data-collapsible="true"]');
            collapsibleGroups.forEach((group, index) => {
                const header = group.querySelector('h3');
                // Collapse Detection Settings and Visualization panels by default
                if (header.textContent.includes('Detection Settings') || 
                    header.textContent.includes('Visualization')) {
                    toggleControlGroup(header);
                }
            });
            
            // Test modal visibility
            console.log('🔍 Modal element on page load:', !!document.getElementById('patchGrid'));
            const modal = document.getElementById('patchGrid');
            if (modal) {
                console.log('✅ Modal found, current display:', modal.style.display);
                console.log('✅ Modal computed style:', window.getComputedStyle(modal).display);
                console.log('✅ Modal z-index:', window.getComputedStyle(modal).zIndex);
            }
        });

    </script>

    <!-- Patch Details Modal - DISABLED (using popup instead) -->
    <div id="patchGrid" class="patch-details-modal" style="display: none !important; visibility: hidden !important;">
        <!-- Modal content disabled - using professional popup instead -->
    </div>

    <!-- Chart.js Library for Histogram -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</body>
</html>