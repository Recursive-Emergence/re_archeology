<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE-Archaeology Framework - Archaeological Discovery Platform</title>
    
    <!-- Google OAuth -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Material Design Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="css/status-enhancements.css">
    <link rel="stylesheet" href="css/visualization-enhancements.css">
    
    <style>
        :root {
            --discovery-panel-width: 320px;
            --chat-panel-width: 320px;
            --header-height: 70px;
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --border-color: #404040;
            --accent-color: #00ff88;
            --text-primary: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        /* Header - Fixed at top */
        .app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            height: var(--header-height);
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 1.5rem;
            z-index: 2000;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .header-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .site-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }
        
        .header-content h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .header-content h1 a {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .header-content h1 a:hover {
            color: var(--accent-color);
        }
        
        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .task-indicator {
            color: var(--accent-color);
            font-size: 0.875rem;
            font-weight: 600;
            min-width: 250px;
            text-align: right;
        }
        
        /* Main content - Full screen below header */
        .main-content {
            position: fixed;
            top: var(--header-height);
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: calc(100vh - var(--header-height));
            overflow: hidden;
        }
        
        /* Map - Full screen background */
        .map-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Discovery Panel - Floating left */
        .discovery-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            width: var(--discovery-panel-width);
            max-height: calc(100vh - var(--header-height) - 120px);
            background: rgba(45, 45, 45, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(64, 64, 64, 0.8);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 1001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .discovery-panel:hover {
            background: rgba(45, 45, 45, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }
        
        .discovery-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(64, 64, 64, 0.6);
            background: rgba(37, 37, 37, 0.8);
            border-radius: 12px 12px 0 0;
        }
        
        .discovery-header h1 {
            font-size: 16px;
            margin-bottom: 4px;
            color: var(--accent-color);
        }
        
        .discovery-header p {
            color: #aaa;
            font-size: 11px;
            margin: 0;
        }
        
        .discovery-controls {
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) var(--bg-primary);
        }
        
        .discovery-controls::-webkit-scrollbar {
            width: 6px;
        }
        
        .discovery-controls::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        .discovery-controls::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        
        .control-group {
            margin-bottom: 12px;
            background: rgba(31, 31, 31, 0.8);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(53, 53, 53, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .control-group h3 {
            font-size: 12px;
            color: var(--accent-color);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group[data-collapsible="true"] h3 {
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }
        
        .control-group[data-collapsible="true"] h3:hover {
            color: var(--accent-color);
        }
        
        .control-group .toggle-icon {
            float: right;
            font-size: 12px;
            transition: transform 0.2s ease;
        }
        
        .control-group.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        
        .control-group .control-content {
            transition: max-height 0.3s ease;
            overflow: hidden;
        }
        
        .control-group.collapsed .control-content {
            max-height: 0;
            opacity: 0.5;
        }
        
        .input-group {
            margin-bottom: 8px;
        }
        
        .input-group label {
            display: block;
            font-size: 11px;
            color: #ccc;
            margin-bottom: 3px;
        }
        
        .input-group input,
        .input-group select {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        
        .btn {
            padding: 8px 14px;
            background: var(--accent-color);
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn:hover {
            background: #00cc6a;
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            background: var(--border-color);
            color: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        .btn-stop {
            background: #ff4444;
            color: var(--text-primary);
        }
        
        .btn-stop:hover {
            background: #cc3333;
        }
        
        .btn-test {
            background: #ff6b35;
            border-color: #ff6b35;
        }
        
        .btn-test:hover {
            background: #e55a2b;
            border-color: #e55a2b;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .button-grid .btn:first-child {
            grid-column: 1 / -1;
        }
        
        .button-grid .btn:nth-child(4) {
            grid-column: 1 / -1;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        .discovery-status {
            padding: 12px 16px;
            background: rgba(37, 37, 37, 0.8);
            border-top: 1px solid rgba(64, 64, 64, 0.6);
            border-radius: 0 0 12px 12px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }
        
        .status-value {
            color: var(--accent-color);
            font-weight: 600;
        }
        
        /* Chat Panel - Floating right */
        .chat-panel {
            position: absolute;
            bottom: 20px; /* Adjusted to move it higher */
            right: 20px;
            width: var(--chat-panel-width);
            max-height: calc(100vh - var(--header-height) - 40px);
            background: rgba(45, 45, 45, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(64, 64, 64, 0.8);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 1001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .chat-panel:hover {
            background: rgba(45, 45, 45, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }
        
        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(64, 64, 64, 0.6);
            background: rgba(37, 37, 37, 0.8);
            border-radius: 12px 12px 0 0;
        }
        
        .chat-header h5 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        
        .chat-header small {
            color: #aaa;
            font-size: 0.875rem;
        }
        
        .auth-section {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
        }
        
        .login-prompt {
            color: #aaa;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .chat-welcome {
            text-align: center;
            color: #aaa;
            font-size: 0.9rem;
        }
        
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            max-width: 85%;
        }
        
        .message.user {
            background-color: #007bff;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .message.ai {
            background-color: #3a3a3a;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .message-content {
            margin-bottom: 0.25rem;
            line-height: 1.4;
        }
        
        .message-time {
            font-size: 0.75rem;
            opacity: 0.7;
        }
        
        .chat-input-section {
            border-top: 1px solid var(--border-color);
            padding: 1rem;
            background-color: var(--bg-secondary);
        }
        
        .chat-input-container {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }
        
        .chat-input-container input {
            flex: 1;
            min-width: 0;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.875rem;
        }
        
        .chat-input-container input:focus {
            outline: none;
            border-color: #007bff;
        }
        
        .chat-input-container input::placeholder {
            color: #666;
        }
        
        .chat-input-container button {
            flex-shrink: 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .chat-input-container button:hover:not(:disabled) {
            background: #0056b3;
        }
        
        .chat-input-container button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
        }
        
        .user-profile-section {
            border-top: 1px solid var(--border-color);
            padding: 0.75rem;
            background-color: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .user-profile-bottom {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
        }
        
        .user-details {
            flex: 1;
            min-width: 0;
        }
        
        .user-name {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.8rem;
            margin-bottom: 0.125rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .user-email {
            color: #aaa;
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .oauth-notice {
            margin-top: 0.5rem;
            padding: 0.25rem;
            font-size: 0.75rem;
            color: #666;
            text-align: center;
            opacity: 0.7;
        }
        
        /* Connection status overlay */
        .connection-status {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 6px 10px;
            border-radius: 16px;
            font-size: 11px;
            z-index: 1200;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
            font-weight: 600;
        }
        
        .connection-status.connected {
            background: rgba(0, 255, 136, 0.25);
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.25);
            border: 1px solid #ff4444;
            color: #ff4444;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
        }
        
        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        
        .scan-animation {
            animation: scanPulse 1.5s ease-out forwards;
        }
        
        @keyframes scanPulse {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        /* G2 Detection Styling */
        .patch.g2-detected {
            animation: g2-pulse 2s ease-in-out infinite;
        }
        
        @keyframes g2-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
        }
        
        .professional-popup {
            background: #1a1a1a !important;
            border: 1px solid #333 !important;
            border-radius: 8px !important;
        }
        
        .professional-popup .leaflet-popup-content {
            margin: 0 !important;
            padding: 0 !important;
        }
        
        .professional-popup .leaflet-popup-content-wrapper {
            background: #1a1a1a !important;
            border-radius: 8px !important;
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            :root {
                --discovery-panel-width: 280px;
                --chat-panel-width: 280px;
            }
        }
        
        @media (max-width: 900px) {
            :root {
                --discovery-panel-width: 250px;
                --chat-panel-width: 250px;
            }
        }
        
        @media (max-width: 600px) {
            .discovery-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                width: calc(100vw - 20px);
                max-height: 200px;
            }
            
            .chat-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                top: auto;
                width: calc(100vw - 20px);
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="app-header">
        <div class="header-content">
            <div class="header-logo">
                <img src="images/site-logo.svg" alt="RE-Archaeology" class="site-logo">
                <h1><a href="#" onclick="window.unifiedApp.goToHomepage(); return false;">RE-Archaeology Framework</a></h1>
            </div>
            <div class="header-actions">
                <div class="task-indicator">
                    <span id="scanningStatusIndicator">Status: Ready</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main content -->
    <div class="main-content">
        <!-- Map Container (Full screen background) -->
        <div class="map-container">
            <div id="map"></div>
            
            <!-- Connection Status -->
            <div class="connection-status disconnected" id="connectionStatus">
                <div class="connection-dot"></div>
                <span>Disconnected</span>
            </div>
        </div>
        
        <!-- Discovery Panel (Floating Left) -->
        <div class="discovery-panel">
            <div class="discovery-header">
                <h1>üèõÔ∏è Structure Discovery</h1>
                <p>Real-time archaeological structure detection using G‚ÇÇ modular kernel system with advanced feature analysis</p>
            </div>
            
            <div class="discovery-controls">
                <!-- Region Selection -->
                <div class="control-group" data-collapsible="true">
                    <h3 onclick="toggleControlGroup(this)">üó∫Ô∏è Scan Region <span class="toggle-icon">‚ñº</span></h3>
                    <div class="control-content">
                        <div class="input-group">
                            <label>Center Latitude</label>
                            <input type="number" id="centerLat" value="52.4751" step="0.0001">
                        </div>
                        <div class="input-group">
                            <label>Center Longitude</label>
                            <input type="number" id="centerLon" value="4.8156" step="0.0001">
                        </div>
                        <div class="input-group">
                            <label>Scan Radius (km)</label>
                            <input type="number" id="scanRadius" value="2" step="0.5" min="0.5" max="10">
                        </div>
                        <div class="input-group">
                            <label>Patch Size (m)</label>
                            <input type="number" id="patchSize" value="40" step="16" min="32" max="256">
                        </div>
                    </div>
                </div>
                
                <!-- Detection Settings -->
                <div class="control-group" data-collapsible="true">
                    <h3 onclick="toggleControlGroup(this)">üéØ Detection Settings <span class="toggle-icon">‚ñº</span></h3>
                    <div class="control-content">
                        <div class="input-group">
                            <label>œÜ‚Å∞ Threshold</label>
                            <input type="number" id="phi0Threshold" value="0.35" step="0.05" min="0" max="1">
                        </div>
                        <div class="input-group">
                            <label>œà‚Å∞ Threshold</label>
                            <input type="number" id="psi0Threshold" value="0.4" step="0.05" min="0" max="1">
                        </div>
                        <div class="input-group">
                            <label>Detection Mode</label>
                            <select id="detectionMode">
                                <option value="windmill" selected>Windmill Structures</option>
                                <option value="tower">Tower Structures</option>
                                <option value="mound">Archaeological Mounds</option>
                                <option value="generic">Generic Structures</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="control-group">
                    <h3>üöÄ Actions</h3>
                    <div class="button-grid">
                        <button class="btn btn-primary" id="startScanBtn">Start Scan</button>
                        <button class="btn btn-stop" id="stopScanBtn" disabled>Stop</button>
                        <button class="btn btn-secondary" id="clearResultsBtn">Clear</button>

                    </div>
                </div>
                
                <!-- Visualization Options -->
                <div class="control-group" data-collapsible="true">
                    <h3 onclick="toggleControlGroup(this)">üëÅÔ∏è Visualization <span class="toggle-icon">‚ñº</span></h3>
                    <div class="control-content">
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="showElevation" checked> Show elevation data
                            </label>
                        </div>
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="showConfidence" checked> Color by confidence
                            </label>
                        </div>
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="showScanAnimation"> Show scan animation
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Discovery Status -->
            <div class="discovery-status">
                <div class="status-item">
                    <span>Session:</span>
                    <span class="status-value" id="sessionStatus">Idle</span>
                </div>
                <div class="status-item">
                    <span>Processed:</span>
                    <span class="status-value" id="processedPatches">0</span>
                </div>
                <div class="status-item">
                    <span>Detections:</span>
                    <span class="status-value" id="totalDetections">0</span>
                </div>
                <div class="status-item">
                    <span>High Confidence:</span>
                    <span class="status-value" id="highConfidenceDetections">0</span>
                </div>
                <div class="status-item">
                    <span>Kernel Status:</span>
                    <span class="status-value" id="kernelStatus">Unknown</span>
                </div>
            </div>
        </div>
        
        <!-- Chat Panel (Floating Right) -->
        <div class="chat-panel">
            <header class="chat-header">
                <h5 class="mb-0">üë©‚Äçüî¨ Bella</h5>
                <small>Guardian of Civilizations</small>
            </header>
            
            <!-- Authentication - Login Only -->
            <section class="auth-section" id="login-section">
                <p class="login-prompt">Sign in to chat with Bella</p>
                <!-- Google OAuth -->
                <div id="g_id_onload"
                     data-client_id="555743158084-ribsom4oerhv0jgohosoit190p8bh72n.apps.googleusercontent.com"
                     data-callback="handleGoogleLogin"
                     data-error_callback="handleGoogleError"
                     data-auto_prompt="false"
                     data-cancel_on_tap_outside="false"
                     data-use_fedcm_for_prompt="false"
                     data-context="signin"
                     data-ux_mode="popup"
                     data-login_uri="/"
                     data-itp_support="true">
                </div>
                <div class="g_id_signin" 
                     data-type="standard" 
                     data-size="medium" 
                     data-theme="outline" 
                     data-text="sign_in_with">
                </div>
        
                <!-- OAuth Configuration Notice -->
                <div id="oauth-config-notice" class="oauth-notice" style="display: none;">
                    <small class="text-muted">
                        <i>‚ö†Ô∏è OAuth configuration needed for production use</i>
                    </small>
                </div>
            </section>
            
            <!-- Chat Messages -->
            <section class="chat-messages" id="chat-messages">
                <div class="chat-welcome" id="chat-welcome">
                    <p>üëã Hi! I'm Bella, your AI assistant for RE-Archaeology.</p>
                    <p class="small">Sign in to start our conversation!</p>
                </div>
            </section>
            
            <!-- Chat Input -->
            <section class="chat-input-section">
                <form id="chat-input-form" class="chat-input-container" style="display: none;">
                    <input type="text" 
                           id="chat-input" 
                           class="form-control" 
                           placeholder="Ask Bella about discoveries..." 
                           disabled>
                    <button type="submit" id="send-btn" class="btn btn-primary" disabled>
                        Send
                    </button>
                </form>
            </section>
            
            <!-- User Profile - Bottom -->
            <section class="user-profile-section" id="user-profile" style="display: none;">
                <div class="user-profile-bottom">
                    <img id="user-avatar" class="user-avatar" src="" alt="">
                    <div class="user-details">
                        <div id="user-name" class="user-name"></div>
                        <div id="user-email" class="user-email text-muted small"></div>
                    </div>
                    <button id="logout-btn" class="btn btn-sm btn-outline-secondary" style="display: none;">
                        Logout
                    </button>
                </div>
            </section>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Application Configuration -->
    <script>
        // Global configuration
        window.AppConfig = {
            googleClientId: '555743158084-ribsom4oerhv0jgohosoit190p8bh72n.apps.googleusercontent.com',
            apiBase: '/api/v1',
            log() {
                console.log('%cüîß RE-Archaeology Configuration', 'color: #2563eb; font-weight: bold; font-size: 14px;');
                console.log(`%c   Google Client ID: %c${this.googleClientId}`, 'color: #64748b;', 'color: #0f172a;');
                console.log(`%c   API Base: %c${this.apiBase}`, 'color: #64748b;', 'color: #0f172a;');
                console.log(`%c   Current Origin: %c${window.location.origin}`, 'color: #64748b;', 'color: #0f172a;');
            }
        };
    </script>
    
    <!-- Discovery API -->
    <script src="js/discovery-api.js"></script>
    <!-- Enhanced Status Management -->
    <script src="js/status-manager.js"></script>
    <script src="js/status-ui-manager.js"></script>
    <!-- Patch Visualization -->        <script src="js/patch-visualization.js?v=13.2"></script>
    
    <!-- Main Application -->
    <script>
        // Unified Application Class
        class UnifiedREArchaeologyApp {
            constructor() {
                // Initialize both discovery and chat functionality
                this.currentUser = null;
                this.isAuthenticated = false;
                this.apiBase = window.AppConfig ? window.AppConfig.apiBase : '/api/v1';
                
                // Discovery functionality
                this.statusManager = new StatusManager();
                this.statusUI = new StatusUIManager(this.statusManager);
                this.map = null;
                this.isScanning = false;
                this.currentSession = null;
                this.patches = new Map();
                this.scanAreaCircle = null;
                
                this.init();
            }
            
            async init() {
                try {
                    console.log('Initializing unified RE-Archaeology app...');
                    
                    // Initialize discovery components
                    await this.initDiscovery();
                    
                    // Initialize chat components
                    this.initChat();
                    
                    // Setup authentication
                    this.checkAuthState();
                    
                    console.log('‚úÖ Unified app initialized successfully');
                } catch (error) {
                    console.error('‚ùå Failed to initialize unified app:', error);
                }
            }
            
            initChat() {
                // Initialize chat functionality
                console.log('Initializing chat...');
                // Chat functionality can be added here later
            }
            
            /**
             * Handle successful Google OAuth login
             */
            handleGoogleLogin(response) {
                console.log('üîê Google login response received:', response);
                
                try {
                    // Decode the JWT token to get user info
                    const token = response.credential;
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    
                    console.log('üë§ User authenticated:', payload);
                    
                    // Store user information
                    this.currentUser = {
                        id: payload.sub,
                        email: payload.email,
                        name: payload.name,
                        picture: payload.picture,
                        token: token
                    };
                    this.isAuthenticated = true;
                    
                    // Update UI to show authenticated state
                    this.updateAuthUI();
                    
                    // Show success message
                    console.log('‚úÖ Google authentication successful');
                    
                    // Optional: Send token to backend for verification
                    // this.verifyTokenWithBackend(token);
                    
                } catch (error) {
                    console.error('‚ùå Error processing Google login:', error);
                    this.handleGoogleError({ error: 'Failed to process login response' });
                }
            }
            
            /**
             * Handle Google OAuth errors
             */
            handleGoogleError(error) {
                console.error('‚ùå Google authentication error:', error);
                
                // Reset auth state
                this.currentUser = null;
                this.isAuthenticated = false;
                
                // Determine error message based on error type
                let errorMessage = 'Authentication failed. Please try again.';
                
                if (error && typeof error === 'object') {
                    if (error.type === 'popup_closed' || error.error === 'popup_closed_by_user') {
                        errorMessage = 'Sign-in popup was closed. Please try again.';
                    } else if (error.type === 'popup_failed_to_open') {
                        errorMessage = 'Unable to open sign-in popup. Please check your popup blocker.';
                    } else if (error.error === 'access_denied') {
                        errorMessage = 'Access denied. Please grant permission to continue.';
                    }
                }
                
                // Show error in UI
                const loginSection = document.getElementById('login-section');
                if (loginSection) {
                    // Show temporary error message
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'auth-error';
                    errorDiv.style.cssText = `
                        color: #ff6b6b;
                        font-size: 12px;
                        margin-top: 8px;
                        padding: 8px;
                        background: rgba(255, 107, 107, 0.1);
                        border-radius: 4px;
                        border: 1px solid rgba(255, 107, 107, 0.3);
                    `;
                    errorDiv.textContent = errorMessage;
                    
                    // Remove any existing error messages
                    const existingError = loginSection.querySelector('.auth-error');
                    if (existingError) {
                        existingError.remove();
                    }
                    
                    loginSection.appendChild(errorDiv);
                    
                    // Auto-remove error after 5 seconds
                    setTimeout(() => {
                        if (errorDiv.parentNode) {
                            errorDiv.remove();
                        }
                    }, 5000);
                }
            }
            
            /**
             * Update UI based on authentication state
             */
            updateAuthUI() {
                const loginSection = document.getElementById('login-section');
                const chatInputForm = document.getElementById('chat-input-form');
                const chatInput = document.getElementById('chat-input');
                const sendBtn = document.getElementById('send-btn');
                const userProfile = document.getElementById('user-profile');
                const chatWelcome = document.getElementById('chat-welcome');
                
                if (this.isAuthenticated && this.currentUser) {
                    // Hide login section
                    if (loginSection) {
                        loginSection.style.display = 'none';
                    }
                    
                    // Show and enable chat input
                    if (chatInputForm) {
                        chatInputForm.style.display = 'flex';
                    }
                    if (chatInput) {
                        chatInput.disabled = false;
                        chatInput.placeholder = 'Ask Bella about discoveries...';
                    }
                    if (sendBtn) {
                        sendBtn.disabled = false;
                    }
                    
                    // Show user profile
                    if (userProfile) {
                        userProfile.style.display = 'block';
                        
                        // Update user info
                        const avatar = document.getElementById('user-avatar');
                        const userName = document.getElementById('user-name');
                        const userEmail = document.getElementById('user-email');
                        const logoutBtn = document.getElementById('logout-btn');
                        
                        if (avatar) {
                            avatar.src = this.currentUser.picture || 'images/default-avatar.svg';
                            avatar.alt = this.currentUser.name || 'User';
                        }
                        if (userName) {
                            userName.textContent = this.currentUser.name || 'User';
                        }
                        if (userEmail) {
                            userEmail.textContent = this.currentUser.email || '';
                        }
                        if (logoutBtn) {
                            logoutBtn.style.display = 'block';
                            logoutBtn.onclick = () => this.logout();
                        }
                    }
                    
                    // Update welcome message
                    if (chatWelcome) {
                        chatWelcome.innerHTML = `
                            <p>üëã Welcome back, ${this.currentUser.name}!</p>
                            <p class="small">I'm Bella, ready to help with your archaeological discoveries.</p>
                        `;
                    }
                    
                    console.log('‚úÖ Auth UI updated for authenticated user');
                } else {
                    // Show login section
                    if (loginSection) {
                        loginSection.style.display = 'block';
                    }
                    
                    // Hide and disable chat input
                    if (chatInputForm) {
                        chatInputForm.style.display = 'none';
                    }
                    if (chatInput) {
                        chatInput.disabled = true;
                    }
                    if (sendBtn) {
                        sendBtn.disabled = true;
                    }
                    
                    // Hide user profile
                    if (userProfile) {
                        userProfile.style.display = 'none';
                    }
                    
                    // Reset welcome message
                    if (chatWelcome) {
                        chatWelcome.innerHTML = `
                            <p>üëã Hi! I'm Bella, your AI assistant for RE-Archaeology.</p>
                            <p class="small">Sign in to start our conversation!</p>
                        `;
                    }
                }
            }
            
            /**
             * Logout user
             */
            logout() {
                console.log('üö™ User logging out');
                
                // Store email before clearing user data
                const userEmail = this.currentUser?.email;
                
                // Reset auth state
                this.currentUser = null;
                this.isAuthenticated = false;
                
                // Update UI
                this.updateAuthUI();
                
                // Optionally revoke Google token
                if (window.google && window.google.accounts && userEmail) {
                    try {
                        window.google.accounts.id.revoke(userEmail, () => {
                            console.log('‚úÖ Google token revoked');
                        });
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not revoke Google token:', error);
                    }
                }
                
                console.log('‚úÖ Logout completed');
            }
            
            /**
             * Check initial authentication state
             */
            checkAuthState() {
                console.log('üîç Checking authentication state...');
                
                // Check for pending Google auth from before app was ready
                if (window._pendingGoogleAuth) {
                    console.log('üîÑ Processing pending Google auth');
                    this.handleGoogleLogin(window._pendingGoogleAuth);
                    delete window._pendingGoogleAuth;
                    return;
                }
                
                // This could check for stored tokens, but for now just ensure UI is in correct state
                this.updateAuthUI();
                
                console.log('‚úÖ Authentication state check completed');
            }
            
            async initDiscovery() {
                // Initialize map
                this.initMap();
                
                // Initialize patch visualization
                this.initPatchVisualization();
                
                // Setup discovery event handlers
                this.setupDiscoveryEvents();
                
                // Try to connect to WebSocket
                try {
                    await this.statusManager.connect();
                    console.log('‚úÖ Discovery WebSocket connected');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Discovery running in offline mode:', error.message);
                    this.setupOfflineMode();
                }
            }

            initPatchVisualization() {
                // Initialize patch visualization system
                if (typeof PatchVisualization !== 'undefined') {
                    this.patchViz = new PatchVisualization();
                    window.patchViz = this.patchViz; // Make globally accessible
                    console.log('‚úÖ Patch visualization initialized');
                } else {
                    console.warn('‚ö†Ô∏è PatchVisualization class not found');
                }
            }
            
            initMap() {
                // Initialize the map
                this.map = L.map('map').setView([52.4751, 4.8156], 13);
                
                // Add base layer (satellite)
                this.satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri'
                }).addTo(this.map);
                
                // Add street layer (initially hidden)
                this.streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                });
                
                // Add LiDAR elevation overlay for Netherlands region
                this.lidarLayer = L.tileLayer('https://service.pdok.nl/rce/ahn/wmts/ahn4_05m_dsm/EPSG:3857/{z}/{x}/{y}.png', {
                    attribution: 'AHN4 LiDAR &copy; PDOK',
                    opacity: 0.6,
                    maxZoom: 16
                });
                
                // Add layer control
                const baseLayers = {
                    'Satellite': this.satelliteLayer,
                    'Street Map': this.streetLayer
                };
                
                const overlayLayers = {
                    'LiDAR Elevation (AHN4)': this.lidarLayer
                };
                
                L.control.layers(baseLayers, overlayLayers).addTo(this.map);
                
                // Add scan area circle
                this.scanAreaCircle = L.circle([52.4751, 4.8156], {
                    color: '#00ff88',
                    fillColor: '#00ff88',
                    fillOpacity: 0.1,
                    radius: 2000
                }).addTo(this.map);
                
                // Handle map clicks for setting scan center
                this.map.on('click', (e) => {
                    if (!this.isScanning) {
                        document.getElementById('centerLat').value = e.latlng.lat.toFixed(6);
                        document.getElementById('centerLon').value = e.latlng.lng.toFixed(6);
                        this.updateScanArea();
                    }
                });
                
                this.updateScanArea();
            }
            
            setupDiscoveryEvents() {
                // Button events
                document.getElementById('startScanBtn').addEventListener('click', () => this.startScan());
                document.getElementById('stopScanBtn').addEventListener('click', () => this.stopScan());
                document.getElementById('clearResultsBtn').addEventListener('click', () => this.clearResults());
                
                // Input events
                document.getElementById('centerLat').addEventListener('change', () => this.updateScanArea());
                document.getElementById('centerLon').addEventListener('change', () => this.updateScanArea());
                document.getElementById('scanRadius').addEventListener('change', () => this.updateScanArea());
                
                // Status manager events
                this.statusManager.on('connectionEstablished', () => {
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                    document.getElementById('connectionStatus').innerHTML = '<div class="connection-dot"></div><span>Connected</span>';
                    document.getElementById('startScanBtn').disabled = false;
                });
                
                this.statusManager.on('disconnected', () => {
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                    document.getElementById('connectionStatus').innerHTML = '<div class="connection-dot"></div><span>Disconnected</span>';
                    document.getElementById('startScanBtn').disabled = true;
                    document.getElementById('stopScanBtn').disabled = true;
                });
                
                this.statusManager.on('sessionStarted', (session) => {
                    this.currentSession = session;
                    this.isScanning = true;
                    document.getElementById('sessionStatus').textContent = 'Scanning';
                    document.getElementById('scanningStatusIndicator').textContent = 'Scanning: 0% (0/0) ‚Ä¢ Initializing...';
                });
                
                this.statusManager.on('sessionCompleted', () => {
                    this.isScanning = false;
                    this.currentSession = null;
                    document.getElementById('sessionStatus').textContent = 'Completed';
                    document.getElementById('scanningStatusIndicator').textContent = 'Status: Completed';
                });
                
                this.statusManager.on('patchResult', (patch) => {
                    this.handlePatchUpdate(patch);
                    
                    // Update progress in header status with detailed information
                    if (this.isScanning && this.statusManager.state?.progress) {
                        const progress = this.statusManager.state.progress;
                        const percentage = Math.round(progress.percentage || 0);
                        const current = progress.current || 0;
                        const total = progress.total || 0;
                        const rate = progress.rate ? Math.round(progress.rate * 10) / 10 : 0;
                        const eta = progress.eta;
                        
                        let statusText = `Scanning: ${percentage}% (${current}/${total})`;
                        if (rate > 0) {
                            statusText += ` ‚Ä¢ ${rate}/s`;
                        }
                        if (eta) {
                            const etaMinutes = Math.round(eta / 60);
                            if (etaMinutes > 0) {
                                statusText += ` ‚Ä¢ ETA: ${etaMinutes}m`;
                            }
                        }
                        
                        document.getElementById('scanningStatusIndicator').textContent = statusText;
                    }
                    
                    // Show scan animation if enabled
                    if (document.getElementById('showScanAnimation')?.checked) {
                        this.showScanAnimation(patch.lat, patch.lon);
                    }
                });
                
                // Listen for periodic status updates to refresh progress display
                this.statusManager.on('statusUpdate', (status) => {
                    if (this.isScanning && status.progress) {
                        const progress = status.progress;
                        const percentage = Math.round(progress.percentage || 0);
                        const current = progress.current || 0;
                        const total = progress.total || 0;
                        const rate = progress.rate ? Math.round(progress.rate * 10) / 10 : 0;
                        const eta = progress.eta;
                        
                        let statusText = `Scanning: ${percentage}% (${current}/${total})`;
                        if (rate > 0) {
                            statusText += ` ‚Ä¢ ${rate}/s`;
                        }
                        if (eta) {
                            const etaMinutes = Math.round(eta / 60);
                            if (etaMinutes > 0) {
                                statusText += ` ‚Ä¢ ETA: ${etaMinutes}m`;
                            }
                        }
                        
                        document.getElementById('scanningStatusIndicator').textContent = statusText;
                    }
                });
            }
            
            setupOfflineMode() {
                // Disable features that require WebSocket connection
                document.getElementById('startScanBtn').disabled = true;
                document.getElementById('stopScanBtn').disabled = true;
                document.getElementById('sessionStatus').textContent = 'Offline Mode';
                document.getElementById('scanningStatusIndicator').textContent = 'Status: Offline';
            }
            
            updateScanArea() {
                const lat = parseFloat(document.getElementById('centerLat').value);
                const lon = parseFloat(document.getElementById('centerLon').value);
                const radius = parseFloat(document.getElementById('scanRadius').value) * 1000;
                
                this.scanAreaCircle.setLatLng([lat, lon]);
                this.scanAreaCircle.setRadius(radius);
                this.map.setView([lat, lon], this.map.getZoom());
            }
            
            async startScan() {
                if (this.isScanning || !this.statusManager.isConnected()) {
                    console.warn('Cannot start scan: already scanning or not connected');
                    return;
                }
                
                // Clear any previous results
                this.clearResults();
                
                const config = {
                    center_lat: parseFloat(document.getElementById('centerLat').value),
                    center_lon: parseFloat(document.getElementById('centerLon').value),
                    scan_radius_km: parseFloat(document.getElementById('scanRadius').value),
                    patch_size_m: parseInt(document.getElementById('patchSize').value),
                    phi0_threshold: parseFloat(document.getElementById('phi0Threshold').value),
                    psi0_threshold: parseFloat(document.getElementById('psi0Threshold').value),
                    detection_mode: document.getElementById('detectionMode').value
                };
                
                try {
                    console.log('üöÄ Starting new discovery session with config:', config);
                    await this.statusManager.startDiscovery(config);
                } catch (error) {
                    console.error('Failed to start scan:', error);
                    alert('Failed to start scan: ' + error.message);
                }
            }
            
            async stopScan() {
                if (!this.statusManager.isConnected()) {
                    return;
                }
                
                try {
                    await this.statusManager.stopDiscovery(this.currentSession?.session_id);
                } catch (error) {
                    console.error('Failed to stop scan:', error);
                }
            }
            
            async clearResults() {
                try {
                    // Clear backend sessions if connected
                    if (this.statusManager.isConnected()) {
                        await this.statusManager.clearSessions();
                    }
                } catch (error) {
                    console.warn('Failed to clear backend sessions:', error);
                }
                
                // Remove all patch layers from map
                this.patches.forEach(patchData => {
                    if (patchData.mapElement) {
                        this.map.removeLayer(patchData.mapElement);
                    }
                });
                
                this.patches.clear();
                
                // Reset session state
                this.currentSession = null;
                this.isScanning = false;
                
                // Reset UI state
                document.getElementById('sessionStatus').textContent = 'Idle';
                document.getElementById('scanningStatusIndicator').textContent = 'Status: Ready';
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('stopScanBtn').disabled = true;
                
                // Reset counters
                document.getElementById('processedPatches').textContent = '0';
                document.getElementById('totalDetections').textContent = '0';
                document.getElementById('highConfidenceDetections').textContent = '0';
                
                // Hide any patch details
                const patchGrid = document.getElementById('patchGrid');
                if (patchGrid) {
                    patchGrid.style.display = 'none';
                }
                
                // Only reset status manager state without disconnecting WebSocket
                // This prevents WebSocket disconnection during active discovery sessions
                this.statusManager.updateState({
                    session: null,
                    scanning: false,
                    progress: {
                        current: 0,
                        total: 0,
                        percentage: 0,
                        rate: 0,
                        eta: null
                    },
                    statistics: {
                        totalPatches: 0,
                        positiveDetections: 0,
                        highConfidenceDetections: 0,
                        averageConfidence: 0,
                        scanStartTime: null,
                        lastUpdateTime: null
                    },
                    errors: []
                });
                
                console.log('‚úÖ Session cleared and UI reset (WebSocket connection preserved)');
            }
            
            handlePatchUpdate(patch) {
                this.patches.set(patch.patch_id, patch);
                this.addPatchToMap(patch);
                
                // Update counters
                document.getElementById('processedPatches').textContent = this.patches.size;
                
                const positivePatches = Array.from(this.patches.values()).filter(p => p.is_positive);
                document.getElementById('totalDetections').textContent = positivePatches.length;
                
                const highConfidencePatches = positivePatches.filter(p => (p.confidence || 0) >= 0.8);
                document.getElementById('highConfidenceDetections').textContent = highConfidencePatches.length;
            }
            
            addPatchToMap(patch) {
                const bounds = this.getPatchBounds(patch);
                const borderColor = this.getPatchColor(patch);
                
                // Determine fill based on detection status and scores
                let fillColor, fillOpacity, borderWeight;
                
                if (patch.is_positive && patch.detection_result?.g2_detected) {
                    // Positive G2 detection - use G2 score for intensity
                    const g2Score = patch.detection_result.g2_final_score || patch.detection_result.g2_confidence || 0;
                    fillColor = borderColor;
                    fillOpacity = Math.max(0.4, g2Score * 0.6 + 0.4);  // 0.4-1.0 based on G2 score
                    borderWeight = 3;  // Thick border for detections
                } else if (patch.is_positive) {
                    // Positive detection but not G2
                    fillColor = borderColor;
                    fillOpacity = Math.max(0.3, (patch.confidence || 0) * 0.5 + 0.3);
                    borderWeight = 2;
                } else {
                    // No detection - use subtle elevation-based fill
                    fillColor = this.getElevationBasedFill(patch);
                    fillOpacity = 0.2;
                    borderWeight = 1;
                }
                
                const rectangle = L.rectangle(bounds, {
                    color: borderColor,
                    weight: borderWeight,
                    fillColor: fillColor,
                    fillOpacity: fillOpacity,
                    className: `patch ${patch.is_positive ? 'positive' : 'negative'} ${patch.detection_result?.g2_detected ? 'g2-detected' : ''}`
                }).addTo(this.map);
                
                // Add popup with professional analyzer-style visualization
                rectangle.bindPopup(`
                    <div class="patch-popup professional" style="width: 400px;">
                        <div class="popup-header" style="background: #252525; padding: 12px; margin: -20px -20px 15px -20px; border-radius: 8px 8px 0 0;">
                            <h4 style="color: #00ff88; margin: 0; font-size: 14px;">Patch ${patch.patch_id} Analysis</h4>
                            <div style="color: #ccc; font-size: 11px; margin-top: 4px;">
                                üìç ${patch.lat.toFixed(4)}, ${patch.lon.toFixed(4)} ‚Ä¢ 
                                Score: <span style="color: ${this.getScoreColor(this.getNumericFinalScore(patch))}">${this.getFinalScore(patch)}</span>
                            </div>
                        </div>
                        
                        <div class="popup-metrics" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px;">
                            <div style="background: #1a1a1a; padding: 8px; border-radius: 4px; border-left: 3px solid #00ff88;">
                                <div style="color: #ccc; font-size: 10px;">${patch.detection_result?.g2_detected ? 'G2 CONFIDENCE' : 'CONFIDENCE'}</div>
                                <div style="color: #fff; font-size: 12px; font-weight: bold;">
                                    ${patch.detection_result?.g2_confidence ? this.formatConfidence(patch.detection_result.g2_confidence) : this.formatConfidence(patch.confidence)}%
                                </div>
                            </div>
                            <div style="background: #1a1a1a; padding: 8px; border-radius: 4px; border-left: 3px solid #ff9f40;">
                                <div style="color: #ccc; font-size: 10px;">G2 FINAL SCORE</div>
                                <div style="color: #fff; font-size: 12px; font-weight: bold;">
                                    ${patch.detection_result?.g2_final_score !== undefined ? patch.detection_result.g2_final_score.toFixed(4) : 'N/A'}
                                </div>
                            </div>
                        </div>
                        
                        ${patch.detection_result?.g2_feature_scores ? `
                        <div class="popup-features" style="margin-bottom: 15px;">
                            <div style="color: #ccc; font-size: 11px; margin-bottom: 8px; font-weight: bold;">
                                G2 FEATURE SCORES
                                ${patch.detection_result.g2_detected ? '<span style="color: #00ff88; font-size: 9px;">‚úì DETECTED</span>' : '<span style="color: #ff6666; font-size: 9px;">‚úó NOT DETECTED</span>'}
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 10px;">
                                ${Object.entries(patch.detection_result.g2_feature_scores).map(([name, score]) => `
                                    <div style="background: #1a1a1a; padding: 6px; border-radius: 3px; display: flex; justify-content: space-between;">
                                        <span style="color: #ccc;">${name.replace(/([A-Z])/g, ' $1').trim()}</span>
                                        <span style="color: ${this.getScoreColor(score)}; font-weight: bold;">${typeof score === 'number' ? score.toFixed(3) : score}</span>
                                    </div>
                                `).join('')}
                            </div>
                            ${patch.detection_result.g2_reason ? `
                            <div style="margin-top: 8px; padding: 6px; background: #0f0f0f; border-radius: 3px; font-size: 9px; color: #aaa;">
                                <strong>Reason:</strong> ${patch.detection_result.g2_reason}
                            </div>` : ''}
                        </div>` : ''}
                        
                        <div class="popup-visualization" style="display: flex; gap: 15px;">
                            <!-- Elevation Heatmap -->
                            <div style="flex: 1;">
                                <h6 style="color: #ccc; margin: 0 0 8px 0; font-size: 11px; text-align: center;">Elevation Pattern</h6>
                                <div id="miniElevationGrid_${patch.patch_id}" class="mini-elevation-grid professional" 
                                     style="display: flex; flex-direction: column; align-items: center; width: 120px; margin: 0 auto;">
                                    <!-- Will be populated with canvas heatmap by JavaScript -->
                                </div>
                            </div>
                            
                            <!-- Professional Histogram -->
                            <div style="flex: 1;">
                                <h6 style="color: #ccc; margin: 0 0 8px 0; font-size: 11px; text-align: center;">Elevation Distribution</h6>
                                <div id="miniHistogram_${patch.patch_id}" style="width: 180px; height: 120px; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; position: relative;">
                                    <canvas width="180" height="120" style="display: block;"></canvas>
                                </div>
                            </div>
                        </div>
                        
                        <div class="popup-status" style="margin-top: 15px; text-align: center; padding: 8px; background: ${this.getConfidenceBackground(patch)}; border-radius: 4px;">
                            <span style="color: ${this.getConfidenceTextColor(patch)}; font-size: 12px; font-weight: bold;">
                                ${this.getConfidenceStatusText(patch)}
                            </span>
                        </div>
                    </div>
                `, {
                    maxWidth: 450,
                    minWidth: 420,
                    className: 'professional-popup'
                });
                
                // Add click handler to show professional visualizations in popup ONLY
                rectangle.on('click', () => {
                    // Longer delay to ensure popup is fully rendered
                    setTimeout(() => {
                        console.log('üéØ Patch clicked:', patch.patch_id);
                        console.log('üìä Patch elevation data structure:');
                        console.log('  - Type:', typeof patch.elevation_data);
                        console.log('  - Is Array:', Array.isArray(patch.elevation_data));
                        console.log('  - Length:', patch.elevation_data?.length);
                        console.log('  - First element type:', typeof patch.elevation_data?.[0]);
                        console.log('  - Sample data:', patch.elevation_data?.slice(0, 3));
                        this.showProfessionalVisualizationInPopup(patch);
                    }, 200);
                });
                
                patch.mapElement = rectangle;
            }
            
            getPatchBounds(patch) {
                // Use the actual patch size from the patch data, or fall back to UI setting
                const patchSizeM = patch.patch_size_m || parseInt(document.getElementById('patchSize').value) || 40;
                const patchSizeKm = patchSizeM / 1000;
                
                // Convert patch size to degrees (more accurate calculation)
                const latOffset = patchSizeKm / 111.32; // 1 degree latitude = ~111.32 km
                const lonOffset = patchSizeKm / (111.32 * Math.cos(patch.lat * Math.PI / 180));
                
                return [
                    [patch.lat - latOffset/2, patch.lon - lonOffset/2],
                    [patch.lat + latOffset/2, patch.lon + lonOffset/2]
                ];
            }
            
            getPatchColor(patch) {
                // Prioritize G2 detection result for positive patches
                if (patch.is_positive && patch.detection_result?.g2_detected) {
                    const g2Score = patch.detection_result.g2_final_score;
                    if (g2Score !== undefined) {
                        // Use G2 final score for color mapping
                        if (g2Score >= 0.7) return '#00ff88';  // High G2 score - bright green
                        if (g2Score >= 0.5) return '#00cc66';  // Good G2 score - medium green  
                        if (g2Score >= 0.3) return '#009944';  // Medium G2 score - darker green
                        if (g2Score >= 0.1) return '#006622';  // Low G2 score - dark green
                        return '#004411';  // Very low G2 score - very dark green
                    }
                }
                
                // Fallback to confidence for non-G2 or negative patches
                const confidence = patch.confidence || 0;
                if (confidence >= 0.7) return '#00ff88';
                if (confidence >= 0.5) return '#00cc66';
                if (confidence >= 0.3) return '#009944';
                if (confidence >= 0.1) return '#006622';
                return '#666666';  // Gray for no detection
            }
            
            getScoreColor(score) {
                if (score >= 0.7) return '#00ff88'; // Bright green
                if (score >= 0.4) return '#00cc66'; // Medium green
                return '#009944'; // Dark green
            }
            
            getElevationBasedFill(patch) {
                // Use elevation statistics for neutral patches
                if (patch.elevation_stats) {
                    const { mean, min, max } = patch.elevation_stats;
                    const range = max - min;
                    if (range > 0) {
                        const normalized = (mean - min) / range;
                        // Use terrain colors for elevation-based fill
                        if (normalized > 0.7) return '#e6f2ff';      // Light blue for high areas
                        if (normalized > 0.5) return '#ccf0cc';      // Light green for mid areas
                        if (normalized > 0.3) return '#ffffcc';      // Light yellow for low-mid areas
                        return '#f0e6d2';                            // Light brown for low areas
                    }
                }
                return '#f5f5f5';  // Default light gray for no elevation data
            }
            
            getConfidenceBackground(patch) {
                // Use G2 score for background if available
                let score = patch.confidence || 0;
                if (patch.detection_result?.g2_detected && patch.detection_result?.g2_final_score !== undefined) {
                    score = patch.detection_result.g2_final_score;
                }
                
                if (score >= 0.7) return 'rgba(0, 255, 136, 0.15)';  // Bright green background
                if (score >= 0.5) return 'rgba(0, 204, 102, 0.15)';  // Medium green background  
                if (score >= 0.3) return 'rgba(0, 153, 68, 0.15)';   // Darker green background
                if (score >= 0.1) return 'rgba(0, 102, 34, 0.15)';   // Dark green background
                return 'rgba(102, 102, 102, 0.1)';  // Gray background
            }
            
            getConfidenceTextColor(patch) {
                // Use G2 score for text color if available
                let score = patch.confidence || 0;
                if (patch.detection_result?.g2_detected && patch.detection_result?.g2_final_score !== undefined) {
                    score = patch.detection_result.g2_final_score;
                }
                
                if (score >= 0.7) return '#00ff88';  // Bright green
                if (score >= 0.5) return '#00cc66';  // Medium green  
                if (score >= 0.3) return '#009944';  // Darker green
                if (score >= 0.1) return '#006622';  // Dark green
                return '#666666';  // Gray
            }
            
            getConfidenceStatusText(patch) {
                if (patch.detection_result?.g2_detected) {
                    const g2Score = patch.detection_result.g2_final_score || patch.detection_result.g2_confidence || 0;
                    if (g2Score >= 0.7) return 'üéØ HIGH CONFIDENCE G2 DETECTION';
                    if (g2Score >= 0.5) return '‚úÖ STRONG G2 DETECTION';
                    if (g2Score >= 0.3) return 'üîç MODERATE G2 DETECTION';
                    if (g2Score >= 0.1) return '‚ö° WEAK G2 DETECTION';
                    return 'üü° G2 DETECTION (LOW SCORE)';
                }
                
                const conf = patch.confidence || 0;
                if (conf >= 0.7) return 'üéØ HIGH CONFIDENCE DETECTION';
                if (conf >= 0.5) return '‚úÖ STRONG DETECTION';
                if (conf >= 0.3) return 'üîç MODERATE DETECTION';
                if (conf >= 0.1) return '‚ö° WEAK DETECTION';
                return '‚ùå NO DETECTION';
            }

            formatConfidence(confidence) {
                if (!confidence) return '0.0';
                // Handle both decimal (0-1) and percentage (0-100) formats
                if (confidence > 1) {
                    // Already a percentage
                    return confidence.toFixed(1);
                } else {
                    // Convert decimal to percentage
                    return (confidence * 100).toFixed(1);
                }
            }

            getFinalScore(patch) {
                // Display G2 final score with proper labeling
                if (patch.detection_result?.g2_final_score !== undefined) {
                    return `G2: ${patch.detection_result.g2_final_score.toFixed(3)}`;
                }
                
                // Show G2 confidence if final score not available
                if (patch.detection_result?.g2_confidence !== undefined) {
                    return `G2: ${patch.detection_result.g2_confidence.toFixed(3)}`;
                }
                
                // Show general confidence
                if (patch.confidence !== undefined) {
                    return `Conf: ${patch.confidence.toFixed(3)}`;
                }
                
                return 'N/A';
            }

            getNumericFinalScore(patch) {
                // Prioritize G2 final score from backend detection result
                if (patch.detection_result?.g2_final_score !== undefined) {
                    return patch.detection_result.g2_final_score;
                }
                
                // Fallback to G2 confidence if final score not available
                if (patch.detection_result?.g2_confidence !== undefined) {
                    return patch.detection_result.g2_confidence;
                }
                
                // Fallback to general confidence as last resort
                return patch.confidence || 0;
            }

            showProfessionalVisualizationInPopup(patch) {
                // Create elevation heatmap visualization with improved data handling
                const elevationGridId = `miniElevationGrid_${patch.patch_id}`;
                const histogramId = `miniHistogram_${patch.patch_id}`;
                
                // Check if containers exist
                const elevationContainer = document.getElementById(elevationGridId);
                const histogramContainer = document.getElementById(histogramId);
                
                if (!elevationContainer || !histogramContainer) {
                    // Retry once if containers aren't ready
                    setTimeout(() => {
                        this.showProfessionalVisualizationInPopup(patch);
                    }, 100);
                    return;
                }
                
                // Prioritize backend structured elevation data
                let elevationData = null;
                if (patch.elevation_data && Array.isArray(patch.elevation_data)) {
                    elevationData = patch.elevation_data;
                } else if (patch.detection_result?.elevation_data && Array.isArray(patch.detection_result.elevation_data)) {
                    elevationData = patch.detection_result.elevation_data;
                }
                
                // Create elevation heatmap and histogram with better error handling
                this.createElevationHeatmap(elevationContainer, patch, elevationData);
                this.createElevationHistogram(histogramContainer, patch, elevationData);
            }
            
            createElevationHeatmap(container, patch, elevationData) {
                // Clear existing content
                container.innerHTML = '';
                
                console.log('üé® createElevationHeatmap called with:');
                console.log('  - Container:', container);
                console.log('  - Patch ID:', patch.patch_id);
                console.log('  - ElevationData type:', typeof elevationData);
                console.log('  - ElevationData structure:', elevationData);
                
                // Check if we have proper 2D elevation data
                if (!elevationData || !Array.isArray(elevationData)) {
                    console.warn('‚ùå No elevation data or not an array');
                    this.showNoElevationData(container);
                    return;
                }
                
                // Handle both 1D flat arrays and 2D arrays
                let rows, cols, flatData;
                
                if (Array.isArray(elevationData[0])) {
                    // 2D array structure
                    rows = elevationData.length;
                    cols = elevationData[0].length;
                    flatData = elevationData.flat().filter(val => typeof val === 'number' && !isNaN(val) && isFinite(val));
                    console.log(`‚úÖ 2D elevation data: ${rows}x${cols} = ${flatData.length} valid points`);
                } else {
                    // 1D array structure - assume square grid
                    flatData = elevationData.filter(val => typeof val === 'number' && !isNaN(val) && isFinite(val));
                    const size = Math.sqrt(flatData.length);
                    rows = cols = Math.floor(size);
                    console.log(`‚úÖ 1D elevation data: ${flatData.length} points -> ${rows}x${cols} grid`);
                }
                
                if (flatData.length === 0) {
                    console.warn('‚ùå No valid elevation data after filtering');
                    this.showNoElevationData(container);
                    return;
                }
                
                // Create canvas for heatmap
                const canvas = document.createElement('canvas');
                canvas.width = 120;  // Slightly larger for better visibility
                canvas.height = 120;
                canvas.style.width = '120px';
                canvas.style.height = '120px';
                canvas.style.border = '1px solid #333';
                canvas.style.borderRadius = '4px';
                
                const ctx = canvas.getContext('2d');
                
                // Calculate display grid parameters
                const cellWidth = canvas.width / cols;
                const cellHeight = canvas.height / rows;
                
                // Find min/max for normalization
                const minElev = Math.min(...flatData);
                const maxElev = Math.max(...flatData);
                const range = maxElev - minElev;
                
                console.log(`üìä Elevation range: ${minElev.toFixed(2)}m to ${maxElev.toFixed(2)}m (range: ${range.toFixed(2)}m)`);
                
                // Ensure we have a valid range
                if (!isFinite(minElev) || !isFinite(maxElev) || range === 0) {
                    console.warn('‚ùå Invalid elevation range');
                    this.showNoElevationData(container);
                    return;
                }
                
                // Create heatmap with terrain colors
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        let value;
                        
                        if (Array.isArray(elevationData[0])) {
                            // 2D array access
                            value = elevationData[row] && elevationData[row][col];
                        } else {
                            // 1D array access
                            value = elevationData[row * cols + col];
                        }
                        
                        if (value === null || value === undefined || !isFinite(value)) {
                            continue;  // Skip invalid cells
                        }
                        
                        // Normalize elevation to 0-1
                        const normalized = (value - minElev) / range;
                        
                        // Create terrain-like colors
                        let r, g, b;
                        if (normalized < 0.3) {
                            // Low areas - blue to green
                            r = Math.floor(normalized * 3 * 50);
                            g = Math.floor(100 + normalized * 3 * 155);
                            b = Math.floor(200 - normalized * 3 * 100);
                        } else if (normalized < 0.7) {
                            // Mid areas - green to yellow
                            const n = (normalized - 0.3) / 0.4;
                            r = Math.floor(n * 200);
                            g = Math.floor(200);
                            b = Math.floor(50 - n * 50);
                        } else {
                            // High areas - yellow to red
                            const n = (normalized - 0.7) / 0.3;
                            r = Math.floor(200 + n * 55);
                            g = Math.floor(200 - n * 200);
                            b = 0;
                        }
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(col * cellWidth, row * cellHeight, cellWidth, cellHeight);
                    }
                }
                
                container.appendChild(canvas);
                
                // Add elevation range info with grid size
                const info = document.createElement('div');
                info.style.cssText = 'font-size: 9px; color: #999; text-align: center; margin-top: 4px;';
                info.innerHTML = `
                    <div>${minElev.toFixed(1)}m - ${maxElev.toFixed(1)}m</div>
                    <div style="font-size: 8px; color: #666;">${rows}√ó${cols} LiDAR Grid</div>
                `;
                container.appendChild(info);
                
                console.log('‚úÖ Elevation heatmap created successfully');
            }
            
            showNoElevationData(container) {
                // Create a simple "No Data" display
                const placeholder = document.createElement('div');
                placeholder.style.cssText = `
                    width: 100px; 
                    height: 100px; 
                    border: 1px solid #333; 
                    border-radius: 4px; 
                    background: #1a1a1a; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center;
                    font-size: 10px;
                    color: #666;
                `;
                placeholder.textContent = 'No Elevation Data';
                container.appendChild(placeholder);
                
                // Add info
                const info = document.createElement('div');
                info.style.cssText = 'font-size: 9px; color: #666; text-align: center; margin-top: 4px;';
                info.textContent = 'Data Unavailable';
                container.appendChild(info);
            }
            
            createRealisticElevationPattern(container, patch) {
                container.innerHTML = '';
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                canvas.style.width = '100px';
                canvas.style.height = '100px';
                canvas.style.border = '1px solid #333';
                canvas.style.borderRadius = '4px';
                
                const ctx = canvas.getContext('2d');
                
                // Get G2 scores to influence pattern
                const scores = patch.detection_result?.g2_feature_scores || {};
                const planarity = scores.Planarity || 0.5;
                const volume = scores.Volume || 0.5;
                const compactness = scores.Compactness || 0.5;
                
                // Create pattern based on archaeological features
                const cellSize = 5;
                for (let x = 0; x < 100; x += cellSize) {
                    for (let y = 0; y < 100; y += cellSize) {
                        // Create elevation based on distance from center and G2 scores
                        const centerX = 50;
                        const centerY = 50;
                        const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2) / 50;
                        
                        // High planarity = more structured pattern
                        // High volume = more elevated areas
                        // High compactness = more concentrated features
                        let elevation = 0.5;
                        
                        if (planarity > 0.8) {
                            // Very structured - might be building foundation
                            elevation = 0.3 + (1 - distFromCenter) * 0.4 * volume;
                        } else if (compactness > 0.5) {
                            // Compact feature - mound or structure
                            elevation = 0.2 + Math.exp(-distFromCenter * 3) * volume * 0.6;
                        } else {
                            // Natural variation
                            elevation = 0.3 + Math.sin(x * 0.2) * Math.cos(y * 0.15) * 0.3 + 
                                       Math.random() * 0.1;
                        }
                        
                        // Convert to color
                        const r = Math.floor(elevation * 180 + 50);
                        const g = Math.floor(elevation * 120 + 100);
                        const b = Math.floor((1 - elevation) * 100 + 50);
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                }
                
                container.appendChild(canvas);
                
                // Add info based on pattern type
                const info = document.createElement('div');
                info.style.cssText = 'font-size: 9px; color: #666; text-align: center; margin-top: 4px;';
                if (planarity > 0.8) {
                    info.textContent = 'Structured Pattern';
                } else if (compactness > 0.5) {
                    info.textContent = 'Compact Feature';
                } else {
                    info.textContent = 'Natural Variation';
                }
                container.appendChild(info);
            }
            
            createPlaceholderElevationHeatmap(container) {
                container.innerHTML = '';
                
                // Create placeholder canvas
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                canvas.style.width = '100px';
                canvas.style.height = '100px';
                canvas.style.border = '1px solid #333';
                canvas.style.borderRadius = '4px';
                
                const ctx = canvas.getContext('2d');
                
                // Create sample elevation pattern
                for (let x = 0; x < 100; x += 5) {
                    for (let y = 0; y < 100; y += 5) {
                        const intensity = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.5 + 0.5;
                        const r = Math.floor(intensity * 180 + 50);
                        const g = Math.floor(intensity * 120 + 80);
                        const b = Math.floor((1 - intensity) * 150 + 100);
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, y, 5, 5);
                    }
                }
                
                container.appendChild(canvas);
                
                // Add placeholder info
                const info = document.createElement('div');
                info.style.cssText = 'font-size: 9px; color: #666; text-align: center; margin-top: 4px;';
                info.textContent = 'Sample Pattern';
                container.appendChild(info);
            }
            
            createElevationHistogram(container, patch, elevationData) {
                // Find the canvas within the container
                const canvas = container.querySelector('canvas');
                if (!canvas) {
                    console.warn('‚ùå No canvas found in histogram container');
                    return;
                }
                
                console.log('üìä createElevationHistogram called with:');
                console.log('  - Patch ID:', patch.patch_id);
                console.log('  - ElevationData:', elevationData);
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                // Handle both 1D and 2D elevation data structures
                let flatData = [];
                
                if (!elevationData || !Array.isArray(elevationData)) {
                    console.warn('‚ùå No elevation data for histogram');
                    this.drawNoDataHistogram(ctx, width, height);
                    return;
                }
                
                if (Array.isArray(elevationData[0])) {
                    // 2D array - flatten it
                    flatData = elevationData.flat().filter(val => typeof val === 'number' && !isNaN(val) && isFinite(val));
                } else {
                    // 1D array - filter directly
                    flatData = elevationData.filter(val => typeof val === 'number' && !isNaN(val) && isFinite(val));
                }
                
                if (flatData.length === 0) {
                    console.warn('‚ùå No valid elevation data after filtering');
                    this.drawNoDataHistogram(ctx, width, height);
                    return;
                }
                
                console.log(`‚úÖ Processing ${flatData.length} elevation points for histogram`);
                
                // Create histogram bins
                const numBins = 16;
                const minElev = Math.min(...flatData);
                const maxElev = Math.max(...flatData);
                const range = maxElev - minElev;
                
                console.log(`üìä Elevation range: ${minElev.toFixed(2)}m to ${maxElev.toFixed(2)}m`);
                
                if (!isFinite(minElev) || !isFinite(maxElev) || range === 0) {
                    console.warn('‚ùå Invalid elevation range for histogram');
                    this.drawFlatHistogram(ctx, width, height, minElev);
                    return;
                }
                
                const binWidth = range / numBins;
                const bins = new Array(numBins).fill(0);
                
                // Fill bins
                flatData.forEach(elev => {
                    const binIndex = Math.min(Math.floor((elev - minElev) / binWidth), numBins - 1);
                    bins[binIndex]++;
                });
                
                console.log('üìä Histogram bins:', bins);
                
                // Draw histogram
                const maxCount = Math.max(...bins);
                if (maxCount === 0) {
                    this.drawNoDataHistogram(ctx, width, height);
                    return;
                }
                
                const barWidth = (width - 20) / numBins;
                const maxBarHeight = height - 30;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                bins.forEach((count, i) => {
                    const barHeight = (count / maxCount) * maxBarHeight;
                    const x = 10 + i * barWidth;
                    const y = height - 15 - barHeight;
                    
                    // Color based on elevation range
                    const binMidpoint = (i + 0.5) / numBins;
                    if (binMidpoint < 0.3) {
                        ctx.fillStyle = '#4CAF50'; // Green for low
                    } else if (binMidpoint < 0.7) {
                        ctx.fillStyle = '#FFC107'; // Yellow for mid
                    } else {
                        ctx.fillStyle = '#FF5722'; // Red for high
                    }
                    
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                    ctx.strokeRect(x, y, barWidth - 1, barHeight);
                });
                
                // Draw axes
                ctx.strokeStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(10, height - 15);
                ctx.lineTo(width - 10, height - 15);
                ctx.moveTo(10, 15);
                ctx.lineTo(10, height - 15);
                ctx.stroke();
                
                // Add labels
                ctx.fillStyle = '#999';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${minElev.toFixed(1)}m`, 15, height - 3);
                ctx.fillText(`${maxElev.toFixed(1)}m`, width - 15, height - 3);
                
                // Add sample count
                ctx.textAlign = 'right';
                ctx.fillText(`n=${flatData.length}`, width - 5, 12);
                
                console.log('‚úÖ Elevation histogram created successfully');
            }
            
            drawNoDataHistogram(ctx, width, height) {
                // Draw axes
                ctx.strokeStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(10, height - 15);
                ctx.lineTo(width - 10, height - 15);
                ctx.stroke();
                
                // Add "No Data" message
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No Elevation Data', width / 2, height / 2);
            }
            
            drawG2BasedHistogram(ctx, width, height, patch) {
                // Create histogram based on G2 feature scores
                const scores = patch.detection_result?.g2_feature_scores || {};
                const entropy = scores.ElevationEntropy || 0.5;
                const planarity = scores.Planarity || 0.5;
                const volume = scores.Volume || 0.5;
                
                // High entropy = more spread out distribution
                // High planarity = more peaked distribution
                // High volume = shifted towards higher elevations
                
                let bins;
                if (entropy > 0.8) {
                    // Very high entropy - uniform distribution
                    bins = new Array(16).fill(1).map(() => Math.random() * 0.5 + 0.5);
                } else if (planarity > 0.8) {
                    // High planarity - peaked distribution
                    bins = new Array(16).fill(0);
                    const peakPos = Math.floor(8 + volume * 4); // Peak position based on volume
                    for (let i = 0; i < 16; i++) {
                        const dist = Math.abs(i - peakPos);
                        bins[i] = Math.exp(-dist * dist / (2 * (1 - planarity) * 10));
                    }
                } else {
                    // Mixed distribution
                    bins = new Array(16).fill(0).map((_, i) => {
                        const pos = i / 15;
                        return Math.exp(-Math.pow(pos - volume, 2) / (2 * entropy * 0.1)) + 
                               Math.random() * entropy * 0.3;
                    });
                }
                
                // Normalize bins
                const maxBin = Math.max(...bins);
                if (maxBin > 0) {
                    bins = bins.map(b => b / maxBin);
                }
                
                // Draw bars
                const barWidth = (width - 20) / bins.length;
                const maxBarHeight = height - 30;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                bins.forEach((value, i) => {
                    const barHeight = value * maxBarHeight;
                    const x = 10 + i * barWidth;
                    const y = height - 15 - barHeight;
                    
                    // Color based on feature interpretation
                    if (entropy > 0.9) {
                        ctx.fillStyle = '#FF6B6B'; // Red for high entropy (possibly noise)
                    } else if (planarity > 0.8) {
                        ctx.fillStyle = '#4ECDC4'; // Teal for structured features
                    } else {
                        ctx.fillStyle = '#45B7D1'; // Blue for mixed features
                    }
                    
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                    ctx.strokeRect(x, y, barWidth - 1, barHeight);
                });
                
                // Draw axes
                ctx.strokeStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(10, height - 15);
                ctx.lineTo(width - 10, height - 15);
                ctx.moveTo(10, 15);
                ctx.lineTo(10, height - 15);
                ctx.stroke();
                
                // Add interpretation label
                ctx.fillStyle = '#999';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                if (entropy > 0.9) {
                    ctx.fillText('High Noise?', width / 2, height - 3);
                } else if (planarity > 0.8) {
                    ctx.fillText('Structured', width / 2, height - 3);
                } else {
                    ctx.fillText('Mixed Pattern', width / 2, height - 3);
                }
            }
            
            drawFlatHistogram(ctx, width, height, elevation) {
                // Single bar for flat elevation
                const barWidth = (width - 20) / 16;
                const barHeight = (height - 30) * 0.8;
                const x = width / 2 - barWidth / 2;
                const y = height - 15 - barHeight;
                
                ctx.fillStyle = '#FFC107';
                ctx.fillRect(x, y, barWidth, barHeight);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // Axes
                ctx.strokeStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(10, height - 15);
                ctx.lineTo(width - 10, height - 15);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#999';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Flat: ${elevation.toFixed(1)}m`, width / 2, height - 3);
            }
            
            drawSampleHistogram(ctx, width, height) {
                // Create sample histogram data
                const sampleBins = [2, 5, 12, 18, 25, 30, 28, 22, 15, 8, 4, 2, 1, 0, 0, 0];
                const maxCount = Math.max(...sampleBins);
                const barWidth = (width - 20) / sampleBins.length;
                const maxBarHeight = height - 30;
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                sampleBins.forEach((count, i) => {
                    const barHeight = (count / maxCount) * maxBarHeight;
                    const x = 10 + i * barWidth;
                    const y = height - 15 - barHeight;
                    
                    // Draw bar
                    ctx.fillStyle = '#00cc66';
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                    
                    // Draw outline
                    ctx.strokeRect(x, y, barWidth - 1, barHeight);
                });
                
                // Draw axes
                ctx.strokeStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(10, height - 15);
                ctx.lineTo(width - 10, height - 15);
                ctx.moveTo(10, 15);
                ctx.lineTo(10, height - 15);
                ctx.stroke();
                
                // Add sample labels
                ctx.fillStyle = '#666';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Sample Data', width / 2, height - 3);
            }

        }
        
        // Google OAuth callbacks
        window.handleGoogleLogin = function(response) {
            console.log('üîê Global Google login callback triggered');
            console.log('Response:', response);
            console.log('UnifiedApp available:', !!window.unifiedApp);
            
            if (window.unifiedApp) {
                window.unifiedApp.handleGoogleLogin(response);
            } else {
                console.error('‚ùå UnifiedApp not available for Google login');
                // Store response for later processing
                window._pendingGoogleAuth = response;
            }
        };
        
        window.handleGoogleError = function(error) {
            console.log('‚ùå Global Google error callback triggered');
            console.log('Error:', error);
            console.log('UnifiedApp available:', !!window.unifiedApp);
            
            if (window.unifiedApp) {
                window.unifiedApp.handleGoogleError(error);
            } else {
                console.error('Google Sign-In Error (no app):', error);
            }
        };
        
        // Toggle function for collapsible control groups
        window.toggleControlGroup = function(headerElement) {
            const controlGroup = headerElement.parentElement;
            const content = controlGroup.querySelector('.control-content');
            const toggleIcon = headerElement.querySelector('.toggle-icon');
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                toggleIcon.textContent = '‚ñº';
                controlGroup.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                toggleIcon.textContent = '‚ñ∂';
                controlGroup.classList.add('collapsed');
            }
        };

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM loaded, initializing app...');
            
            // Log configuration
            if (window.AppConfig) {
                window.AppConfig.log();
            }
            
            // Update Google OAuth with dynamic client ID
            const googleOnload = document.getElementById('g_id_onload');
            if (googleOnload && window.AppConfig) {
                googleOnload.setAttribute('data-client_id', window.AppConfig.googleClientId);
                googleOnload.setAttribute('data-error_callback', 'handleGoogleError');
                console.log('‚öôÔ∏è Google OAuth configured with client ID:', window.AppConfig.googleClientId);
            }
            
            // Initialize the unified app
            window.unifiedApp = new UnifiedREArchaeologyApp();
            
            // Debug: Check if Google API is loaded
            if (window.google && window.google.accounts) {
                console.log('‚úÖ Google API loaded successfully');
            } else {
                console.log('‚ö†Ô∏è Google API not yet loaded, will retry...');
                // Retry after a short delay
                setTimeout(() => {
                    if (window.google && window.google.accounts) {
                        console.log('‚úÖ Google API loaded on retry');
                    } else {
                        console.error('‚ùå Google API failed to load');
                    }
                }, 2000);
            }
        });
        
        // Additional check when window is fully loaded
        window.addEventListener('load', function() {
            console.log('üåç Window fully loaded');
            
            // Final check for Google API
            if (window.google && window.google.accounts) {
                console.log('‚úÖ Google API confirmed ready');
                
                // Initialize Google Sign-In if not already done
                try {
                    window.google.accounts.id.initialize({
                        client_id: window.AppConfig?.googleClientId || '555743158084-ribsom4oerhv0jgohosoit190p8bh72n.apps.googleusercontent.com',
                        callback: window.handleGoogleLogin,
                        error_callback: window.handleGoogleError,
                        auto_select: false,
                        cancel_on_tap_outside: false
                    });
                    console.log('‚úÖ Google Sign-In re-initialized');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Google Sign-In initialization warning:', error);
                }
            } else {
                console.error('‚ùå Google API still not available after window load');
            }
        });
        
        // Initialize collapsible panels on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize collapsible panels - collapse some by default
            const collapsibleGroups = document.querySelectorAll('.control-group[data-collapsible="true"]');
            collapsibleGroups.forEach((group, index) => {
                const header = group.querySelector('h3');
                // Collapse Detection Settings and Visualization panels by default
                if (header.textContent.includes('Detection Settings') || 
                    header.textContent.includes('Visualization')) {
                    toggleControlGroup(header);
                }
            });
            
        });

    </script>

    <!-- Patch Details Modal - DISABLED (using popup instead) -->
    <div id="patchGrid" class="patch-details-modal" style="display: none !important; visibility: hidden !important;">
        <!-- Modal content disabled - using professional popup instead -->
    </div>

    <!-- Chart.js Library for Histogram -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</body>
</html>